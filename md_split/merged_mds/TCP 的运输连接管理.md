### 关键词提取 - 分块 1
续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫作尾部丢弃策略(tail-droppolicy)。
路由器的尾部丢弃往往会导(cid:7175)一连串分组的丢失，这就使发送方出现超时重传，使TCP进入拥塞控制的慢开始状态，结果使TCP连接的发送方突然把数据的发送速率降低到很小的数值。更为严重的是，在网络中通常有很多的TCP连接（它们有不同的源点和终点），这些连接中的报文段通常是复用在网络层的IP数据报中传送的。在这种情况下，若发生了路由器中的尾部丢弃，就可(cid:7126)会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步(globalsynchronization)。
全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。

**关键词**: 尾部丢弃策略 路由器的尾部丢弃 拥塞控制的慢开始状态 TCP连接 报文段 IP数据报 全局同步


### 关键词提取 - 分块 2
全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。
为了避免发生网络中的全局同步现象，在1998年提出了主动队列管理AQM(ActiveQueueManagement)。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，因而有可(cid:7126)使网络拥塞的程度减轻，甚(cid:7169)不出现网络拥塞。AQM可以有不同实现方法，其中曾流行多年的就是随机早期检测RED(RandomEarlyDetection)oRED还有几个不同的名称，如RandomEarlyDrop或RandomEarlyDiscard（随机早期丢弃）。
实现RED时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED就按照规定的算法先计算当前的平均队列长度。
(1)若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。

**关键词**: 全局同步 主动队列管理AQM 路由器 队列长度 分组 网络拥塞 随机早期检测RED 随机早期丢弃 随机早期discard 最小门限 最大门限


### 关键词提取 - 分块 3
(1)若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。
(2)若平均队列长度超过最大门限，则把新到达的分组丢弃。
(3)若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率p把新到达的分组丢弃（这就体现了丢弃分组的随机性）。
由此可见，RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度达到一定数值时），就以概率p丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥塞控制。
在RED的操作中，最难处理的就是丢弃概率p的选择，因为p并不是个常数。对每一个到达的分组，都必须计算丢弃概率p的数值。IETF曾经推荐在互(cid:7110)网中的路由器使用RED机制[RFC2309]，但多年的实践证明，
公布的RFC7567已经把过去的RFC2309列为“陈旧的RED的使用效果并不太理想。因此，在2015年

**关键词**: 计算机网络 队列长度 最小门限 最大门限 丢弃概率p RED机制 全局性的拥塞控制 互连网路由器 RFC2309 RFC7567


### 关键词提取 - 分块 4
＂，并且不再推荐使用RED。对路由器进行主动队列管理AQM仍是必要的。AQM实际上就是对路由器中的分组排队进行智(cid:7126)管理，而不是简单地把队列的尾部丢弃。现在已经有几种不同的算法来代替旧的RED,但
都还在实验阶段。目前还没有一种算法(cid:7126)够成为IETF的标准，读者可注意这方面的进展。
5.9TCP的运输连接管理TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP运输连接的建立和释•246•放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：连接建
立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。
在TCP连接建立过程中要解决以下三个问题：
(1)要使每一方能够确知对方的存在。
(2)要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
(3)能够对运输实体资源（如缓存大小、连接
TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫作客户(client),中的项目等）进行分配。
表而被动等待连接建立的应用进程叫作服务器(server)。

**关键词**: 计算机网络 路由器 主动队列管理(AQM) RED 分组排队 算法 IETF TCP 运输连接 面向连接协议 运输连接建立 运输连接释放 连接建立 数据传送 连接释放 运输连接管理 客户(client) 服务器(server)


### 关键词提取 - 分块 5
表而被动等待连接建立的应用进程叫作服务器(server)。
5.9.1TCP的连接建立TCP建立连接的过程叫作握手，握手需要在客户和服务器之间交换三个TCP报文段。图5-28画出了三报文握手辽、建立TCP连接的过程。
视频讲解客户.•
IASYN­
SENT！
ESTAB-i
LISHED服务器：乏于三三三二＞
l
ESTAB-i
LISHED
il
::----：:！:：：：：二：：：：：：：：：：：：：二二：：二：：：：：：：：：：：：：：：：：：：？？、？亡之：“二：：l
,图5-28用三报文握手建立TCP连接假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。最初两端的TCP进程都处于CLOSED（关闭）状态。图中在主机下面的方框分别是TCP进程所处的状态。请注意，在本例中，A主动打开连接，而B被动打开连接。
一开始，B的TCP服务器进程先创建传输控制块TCB@，准备接受客户进程的连接请求。
然后服务器进程就处千LISTEN（收听）状态，等待客户的连接请求。如有，即做出响应。

**关键词**: 服务器 客户 TCP报文段 握手 TCP连接 ESTABLISHED LISTEN TCB


### 关键词提取 - 分块 6
然后服务器进程就处千LISTEN（收听）状态，等待客户的连接请求。如有，即做出响应。
CD注：三报文握手是本教材首次采用的译名。在RFC793(TCP标准的文档）中使用的名称是threewayhandshake,但这
”“个名称很难译为准确的中文。例如，以前本教材曾采用三次握手这个广为流行的译名。其实这是在次握手过程中交换了三一个报文，而并不是进行了三次握手（这有点像两个人见面进行一次握手时，他们的手上下摇晃了三次，但这并非进行了三次握
””“手）。最近再次重新阅读了RFC793文档，发现有这样的表述：“threeway(threemessage)handshake。可见采用三报文握手这样的译名，在意思的表达上应当是比较准确的。请注意，handshake使用的是单数而不是复数，表明只是一次握手。
＠注：传输控制块TCB(TransmissionControlBlock)存储了每一个连接中的一些重要信息，如：TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前的发送和接收序号，等等。

**关键词**: 服务器进程 客户 LISTEN状态 连接请求 三报文握手 RFC793 TCP标准 传输控制块TCB


### 关键词提取 - 分块 7
•247•A的TCP客户进程也是首先创建传输控制块TCB。然后，在打算建立TCP连接时，向
B发出连接请求报文段，这时首部中的同步位SYN=l,同时选择一个初始序号s
eq=x。
TCP规定，SYN报文段（即SYN=I的报文段）不(cid:7141)携带数据，但要消(cid:7108)掉一个序号。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。
B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置l，确认号是ack=x+1,同时也为(cid:7151)己选择一个初始序号s
eq=y。
请注意，这个报文段也不(cid:7126)携带数据，但同样要消(cid:7108)掉一个序号。这时TCP服务器进程进
入SYN-RCVD（同步收到）状态。
TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置l，确认号ack=y+I,而(cid:7151)己的序号s
果不携带数据则不消(cid:7108)序号，在这种情况下，下一个数据报文段的序号仍是s
时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。

**关键词**: TCP TCB SYN ACK SYN-SENT SYN-RCVD ESTABLISHED


### 关键词提取 - 分块 8
时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。
eq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如eq=x+1。这当B收到A的确认后，也进入ESTABLISHED状态。
上面给出的连接建立过程叫作三报文握手。请注意，在图5-28中B发送给A的报文段，也可拆成两个报文段。可以先发送一个确认报文段(ACK=l,ack=x+1)，然后再发送一
个同步报文段(SYN=1,eq=y)。这样的过程就变成了四报文握手，但效果是一样的。
s为什么A最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了B,因(cid:7100)产生错误。
所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文丢失而未收到确认。千是A再重传一次连接请求。后来收到了确认，建
立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个
丢失，第二个到达了B,没有“已失效的连接请求报文段”。
现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某

**关键词**: TCP ESTABLISHED 三报文握手 确认报文段 同步报文段 四报文握手 连接请求报文段


### 关键词提取 - 分块 9
现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某
些网络(cid:7188)点长时间滞留了，以(cid:7175)延误到连接释放以后的某个时间才到达B。本来这是一个早
已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连
接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了。
由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数
据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样
白(cid:7178)浪费了。
采用三报文握手的办法，可以防止上述现象的发生。例如在刚才的异常情况下，A不会向B的确认发出确认。B由千收不到确认，就知道A并没有要求建立连接。
5.9.2TCP的连接释放TCP连接释放过程比较复杂，我们仍结合双方状态的改变来阐明连接释放的过程。

**关键词**: 计算机网络 网络点 报文段 连接请求 连接释放 确认报文段 运输连接 三报文握手 TCP连接释放


### 关键词提取 - 分块 10
数据传输结束后，通信的双方都可释放连接。现在A和B都处于ESTABLISHED状态（如图5-29所示）。A的应用进程先向其TCP发出连视狗讲解接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止•248•控制位FIN置1,其序号seq=u,它等千前面已传送过的数据的最后一个字(cid:7192)的序号加1。
这时A进入FIN-WAIT-I（终止等待l)状态，等待B的确认。请注意，TCP规定，FIN
报文段即使不携带数据，它也消(cid:7107)掉一个序号。
客户三ASTAB-i
SHEDj?：：：：二：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：i(三ESTAB-I迪知
,i;:ESTAB-:服务器FIN-
l
WAIT-1ji—习�_｀＇＿,seq二兰�CLOSE-i
WAIT
寸，心芯加"~心＇，心~泌心｀｀，＄u+\＿＿l！被动关闭LAS1图5-29TCP连接释放的过程B收到连接释放报文段后即发出确认，确认号是ack=u+I,而这个报文段(cid:7164)己的序号

**关键词**: 数据传输 连接释放 FIN位 序号 FIN报文段 TCP规定 序号 TCP连接 ESTABLISHED状态 FIN-WAIT-I状态 CLOSE-i状态 被动关闭


### 关键词提取 - 分块 11
是V,等千B前面已传送过的数据的最后一个字(cid:7188)的序号加l。然后B就进入CLOSE­
WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处千半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这
个状态可(cid:7126)会持续一段时间。
A收到来(cid:7149)B的确认后，就进入FIN-WAIT-2（终止等待2)状态，等待B发出的连接释放报文段。
若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连
接释放报文段必须使FIN=1。现假定B的序号为w（在半关闭状态B可(cid:7126)又发送了一些数
据）。B还必须重复上次已发送过的确认号ack=u+l。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。
A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置l,确认号ack=w+1,而(cid:7163)己的序号是seq=u+I

**关键词**: 计算机网络 TCP服务器进程 TCP连接 高层应用进程 FIN=1 LAST-ACK状态 CLOSE-WAIT状态 半关闭状态 终止等待2状态


### 关键词提取 - 分块 12
（根据TCP标准，前面发送过的FIN报文
段要消(cid:7107)一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAITtimer)设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫作最长报文段寿命(MaximumSegmentLifetime),RFC793建议设为2分钟。但这完全是从工程上来考虑的，对于现在的网络，MSL=2分钟可(cid:7126)太长
了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。因此，从A进入
到TIME-WAIT状态后，要经过4分钟才(cid:7141)进入到CLOSED状态，才(cid:7126)开始建立下一个新•249•的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。
为什么A在TIME-WAIT状态必须等待2MSL的时间呢？这有两个理由。

**关键词**: 计算机网络 TCP标准 FIN报文段 消序号 TIME-WAIT状态 TCP连接 时间等待计时器 TIME-WAITtimer MSL 最长报文段寿命 RFC793 工程 网络 MSL值 CLOSED状态 传输控制块TCB TIME-WAIT状态


### 关键词提取 - 分块 13
为什么A在TIME-WAIT状态必须等待2MSL的时间呢？这有两个理由。
第一，为了保证A发送的最后一个ACK报文段(cid:7126)够到达B。这个ACK报文段有可(cid:7126)丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就(cid:7126)在2MSL时间内收到这个重传的FIN+ACK报
文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到
CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后
立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。
第二，防止上一(cid:7194)提到的”已失效的连接请求报文段出现在本连接中。A在发送完最
后一个ACK报文段后，再经过时间2MSL,就可以使本连接持续的时间内所产生的所有报
文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

**关键词**: TIME-WAIT状态 2MSL时间 ACK报文段 FIN+ACK报文段 LAST-ACK状态 CLOSED状态 连接请求报文段


### 关键词提取 - 分块 14
文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。
”B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早一止匕=·°上述的TCP连接释放过程是四报文握手。
除时间等待计时器外，TCP还设有一个保活计时器(keepalivetimer)。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不(cid:7126)再收到客户发来的数据。因此，应当有措施使服务器不要再(cid:7179)(cid:7180)等待下去。这就是
使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常
是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75
秒钟发送一次。若一连发送IO个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。
5.9.3TCP的有限状态机才-1一主I为了更清晰地看出TCP连接的各种状态之间的关系，图5-30给出了

**关键词**: 网络 传输控制块TCB TCP连接 时间等待计时器 保活计时器 探测报文段 有限状态机


### 关键词提取 - 分块 15
TCP的有限状态机。图中每一个方框是TCP可(cid:7126)具有的状态。每个方框中的大写英文字符串是TCP标准所使用的TCP连接状态名。状态之间的箭头视抑讲解表示可(cid:7131)发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。请注意图中有三种不同的箭头。粗实线箭头表示对客户进程的正常变迁。
粗虚线箭头表示对服务器进程的正常变迁。另一种细线箭头表示异常变迁。
我们可以把图5-30和前面的图5-28、图5-29对照起来看。在图5-28和图5-29中左边客户进程从上到下的状态变迁，就是图5-30中粗实线箭头所指的状态变迁。而在图5-28和5-29右边服务器进程从上到下的状态变迁，就是图5-30中粗虚线箭头所指的状态变迁。
还有一些状态变迁，例如连接建立过程中的从LISTEN到SYN-SENT和从SYN-SENT到SYN-RCVD。读者可分析在什么情况下会出现这样的变迁（见习题5-43)。
•250•

**关键词**: TCP 状态机 TCP连接状态 客户进程 服务器进程 异常变迁 LISTEN SYN-SENT SYN-RCVD


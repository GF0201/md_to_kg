H2 都有完整的
压 发送数据时， 从协议的层次上看， 数据的流动如图
五 层协议栈， 但路 由 器在转发分组时使用的协议栈只有下面的三层 G)。 数据进 入路 由 器后要
先从物理层上到网络层， 在转发表中找到下一 跳的地址后， 再下到物理层转发出 去。 因 此，
数据从主 机 凡 传送到主机 H2 需要在路径中的各节点的协议栈向上和向下流动 多次， 如图中
的浅 灰 色 箭 头 所示。

所示。 主机 H 几

3-l(b)

D

然 而 当 我们专 门 研 究数据链路层的问题时， 在许 多情况下我们可以只关 心 在协议栈中
水平方向的各数据链路层。 千是， 当 主 机 H 1 向主机 H2 发送数据时， 我们可以想 象数据就是
在数据链路层从左向右沿水平方向传送， 如图3-2 中从左到右的粗 箭 头 所示 ， 即通过以下这
样的链路：

凡 的链路层一民 的链路层一民 的链路层一 民 的链路层一止 的链路层

H I

H2

图3 -2 只 考虑 数据 在 数据链 路 层的流动

图 3-2 指 出 ， 从数据链路层来看， 凡 到 H2 的通信 可以看成 由 四 段不 同 的链路层通 信 组
成， 即： H 1 -R 1 , R 1 -R 2,  R 尸 民 和 R 3 - H2。 这四 段不同 的链路层可能采用不 同 的数据链
路层协议。

3 . 1   数据链路层的几个共 同 问 题

本节重 点讨论使用点 对点 信 道的数据链路层的一 些基 本 问题。 其中的某些概念 对广 播

信 道 也 是适 用的。

．

扫 一扫

回“

．

．

。

回

事

3

．

l

l

据数

链

路

禾

晴

贞

-

“

“

"

，

，

我

门
1

在

、

这

里

要

明

确

，

下

所

1
胃

路
链、

mk
l
（

）
就

是

从

一

个

链

节

口
各
占�

和

数

据

链

廿
P

令

B

点

的

／

一

护
 各
段

是
并
不
乡物
戈
理

路

（

有

线

或

无

线

）

而

中

—
司

没

有

／

任

何

其

1
也

的

交

奂
1

节

间

的

通

信

路

径

主
往
1

妇

又
工

过

许

多

艾
f

这

样

甘
勺

护令
连

在

进
io

了
1

数

据

通

信

时

，

两

台

计

算

机

之

可

见

链

路

只

是

－

条

－

路

径

的

组

成

部

分

至

相
lj
占�

。

频

畔

融视

。

数

据

链

一

路

必

须

有

条

物

Cd
理

ata

h

nk

）
则

是

另

入1

概

。

念

这

是

因

为

当

需

要

在

条

线

路

上

传

送

数

据

，

时

除

了

配

，

卜

还

必

夕／
员

有

一

些

必

要

的

通

信

协

议

来

控

线

些

数

据

的

传

输

将

在

后

面

几

节

讨

论

。

）

若

把

实

现

这

些

协

议

的

硬

件

和

欠
车

件

加

到

链

路

上

＇

成

了

数

据

链

路

0

在

最

常

用

这

告
l}
就
构

这
(
现

句 注 ： 当 路 由 器 之 间 在 交 换 路 由 信 息 时 ， 根 据 所使 用 的 路 由 选 择 协议 的 不 同 ， 也 有可 能 需 要 使 用 运输层 协 议 。 见 下 一 章 的

4.5 节 。

•  72  •

的方法是使用网络适配器（既有硬件， 也包括软件） 来实 现这些协议。 一般的适配器都包括
了 数据链路层和物理层这两层的功能。

也 有人采用另 外的术语。 这就是把链路分为物 理链路和逻 辑链路。 物 理链路就是上面

所说的链路， 而逻辑链路就是上面的数据链路， 是物理链路加上必要的通信 协议。

早 期 的数据通信 协议 曾 叫 作通信规程( p rocedu re)。 因 此在数据链路层， 规程和协议是同

义语。

下 面再介绍点对点信 道的数据链路层的协议数据单元一一－帧 。
数据链路层把网络层交下来的数据构成 帧发送到链路上， 以及把接收到的帧中的数据
取出并上交给网络层。 在互联网中， 网络层协议数据单元就是 IP 数据报（或简 称为数据报、
分组或包）。

为了把主要精力 放在点对点信道的数据链路层协议上， 可以采用如 图 3-3( a)所示的 三 层
模 型 。 在这种 三 层模 型 中， 不 管 在哪 一段链路上的通信（主机和路 由 器之间或两个路 由 器之
间）， 我们都看成是节点和节点的通信（如 图 中的节点 A 和节点 B)， 而每个节点只有下 三
层

网络层、 数据链路层和物理层。

节 点 A

节 点 B

网 络 层

物理层

“ 雪 ， ， ＿

链 路上传送的是电信 号或光信号

， ， m、

节 点 A

数据链路层

链路

(a) 三层的简 化模型

链路 上传送的是帧

链路

(b) 只 考虑 数据 链路层

节 点 B

图 3-3 使用 点对点信道 的 数据 链路层

点对点信 道的数据链路层在进 行通信时的主要步骤 如下：
(1)节点A的数据链路层把网络层交下 来的IP数据报添加首部和尾部封装成帧。
(2)节点A把封装好的帧发送给节点B的数据链路层。
(3)若节点 B 的数据链路层收到的帧无差错， 则 从收到的帧中提取 出 IP 数据报交给上

面的网络层； 否 则 丢弃这个帧。

数据链路层不必考虑 物 理层如 何实现比特传输的细节。 我们甚 至还可以更 简单地 设想

好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方， 如 图3-3(b)所示。
扫

3 . 1 .2  三个基本 问 题

扫

一

数据链路层协议有许多种， 但有 三 个基 本问题则 是共同的。 这 三 个基本

问题是： 封装成帧 、 透明传输和差错检测 。 下面分别讨论这三个基本问题。

酱视频讲解

•  73  •

1 . 封装成帧

封装 成帧( framing)就是在一段数据的前后分别添加首部和尾部 ， 这样就构成 了 一个帧。
接收端在收到物理层上交的比特流后， 就能根据首部和尾部的标记 ， 从收到的比特流中识别
帧的开始和结束。 图3-4 表示用帧首部和帧尾部封装成帧的一般概念。 我们知 道 ， 分组交换
的一个重要概念就是： 所有在互联网上传送的数据都以分组（即 IP 数据报） 为传送单位。
网络层的 IP 数据报传送到数据链路层就成为帧的数据部分。 在帧的数据部分的前面和后面
分别添加上首部和尾部 ， 构成 了 一个完整的帧。 这样的帧就是数据链路层的数据传送单元。
一个帧的帧长等于 帧的数据部分长度加上帧首部和帧 尾部的长度。 首部和尾部的一个重要作
用就是进 行 帧定 界（即确定帧的界 限）。 此外 ， 首部和尾部还 包括许 多必要的控制信 息。 在
发送帧 时 ， 是从帧首部开始发送的。 各种数据链路层协议都对帧首部和帧尾部的格式有明 确
的规定。 显 然 ， 为 了 提 高 帧的传输效率， 应 当 使帧的数据部分长度尽 可能地大千首部和尾部
的长度。 但是， 每一种链路层协议都规定了 所能传送的帧的数据部分长度上限
最大传送
单 元 MT U ( M aximum T ran sfe r Unit)。 图3-4 给出了 帧的首部和尾部的位置 ， 以及 帧的数据部
分与 M TU 的关系。

帧开始
l
发送
一 门仇 首 部 1
臼

『

I

从这里升始 发送

IP 数据报

帧 结 束l

帧 的数可 部 分

1 帧尾 部

<  MTU

|

数据链路 层的帧 长

图 3-4 用 帧 首 部 和 帧尾部封装成帧

当 数据是 由 可 打 印 的 ASCI I 码组成的文本文件时 ， 帧 定 界可以使用特殊的帧定 界 符。
我们知 道 ， ASCII 码是 7 位编码 ， 一共可组合成128 个不同的 ASCII 码 ， 其中可 打 印 的有
95 个 气 而不可打 印的控制字符有33 个。 图3-5 的例子可说明 帧定界的概念。 控制字符 SOH
( Start  Of  Header)放 在一 帧 的最前 面 ， 表示 帧的首部开 始 。 另 一个控制字符 EOT ( En d   Of
Tran smi s sion)表示 帧的结束。 请注意 ， SOH 和 EOT 都是控制字符的名称。 它们的十六进制
编码分别是 01（ 二 进制是 00000001 ) 和 04（二进制是 00000100)。 SOH （ 或 EOT ) 并不是
S,  0,  H（或 E, 0, T ) 三个字符。 此外 ， 为了 强调帧定界符的作 用， 与 帧定界符无关的控制
信 息在图3-5 中都省 略 了 。

压

帧

符

三

发 送 在 前

装 在 帧 中的数据部分

帧

图 3 -5 用 控制字符进 行 帧 定 界的方法举例

帧 结 束 符

“

注 ：

可 打 印 的字符

”

“

就 是

可 以 从 键盘 卜 输 入 的 字符

＂

（ 因 而 也 是 可 打 印 出 的 ） 。 我 们 使 用 的 标准键盘有 47 个 键可输入

94 个字符 （ 包括 使 用 Shift 键 ） ， 加 上 空格键 ， 一 共 可 输 入 95 个 可 打 印 字 符 。

O

•  74  •

当 数据在传输中出现 差 错 时， 帧 定 界 符 的作 用更 加明 显 。 假定发送端在 尚 未 发送完一
个帧时突 然出故 障， 中断 了 发送。 但 随后很快又恢复 正常， 千是重新从头开始发送刚 才未发
送完的帧。 由 于使用 了 帧定界符， 接收端 就 知 道前面收到的数据是个不完整的帧（只有首部
开 始 符 SOH 而没有传输结束 符 EOT )， 必 须 丢 弃 。 而后面收到的数据有明 确 的帧定界 符
( SOH 和 EOT )， 因 此这是一个完整的帧， 应当收下。

2. 透明传输

由 千帧的开始和结束的标记使用专 门指明的控制字符， 因 此， 所传输的数据中的任何 8 比

特的组合一定不允许和用作帧定界的控制字符的比特编码一样， 否则 就会出现帧定界的错误。

当 传送的帧是用文本文件组成的帧 时（文本文件中的字符都是从键盘上输入的）， 其数
据部分显 然 不 会 出 现像 SOH 或 EOT 这样的帧 定 界控制字符。 可见不管从键盘上输入 什么字
符都可以放在这样的帧中传输过去， 因 此这样的传输就是透明 传输。

但 当数据部分是非 ASCII 码的文本文件时（如 二 进制代码的计算机程序或图像等）， 情
况就不 同 了 。 如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 这种控制字符一样
（如图3-6 所示）， 数据链路层就会错误地 ” 找到帧的边界 “， 把部分帧收下（误认为是个完
整的帧）， 而把剩 下 的那 部分数据丢 弃（这部分找 不到帧定界控制字符 SOH )。

“

出 现 了

EOT "

完整的帧

数据部分

SOH

发 送 在 前 误 认 为 是

个帧

一

被接 收端 当 作 无效帧而丢弃

图3-6 数据部分恰好 出 现与 EOT 一样的代码

“ EOT ” 时就传不过去 了 。 数据中的 “ EOT ” 将被接收端错 误地解释为

像 图 3-6 所示的帧 的传输显 然 就 不 是 “ 透明 传输 ＂， 因 为当 遇到数据中碰 巧出现字符
“ 传输结束 ＂ 的控制
字符， 而 在其后面的数据 因 找 不到 “ SOH " 被接收端 当 作无效帧而丢弃。 但实际上在数据中
出现的字符 “ EOT " 并非控制字符而仅仅是二进制数据 000001 00。

前 面提到的 ＂ 透 明 ” 是一个很 重要的术语。 它表示 ： 某 一 个 实 际存 在 的 事物看起来却
好像 不存在一样（例如， 你看不见在你前面有块 1 00％透明 的玻璃的存在）。 ” 在数据链路层
透明 传送数据 ” 表示无论 什么样的比特组合的数据， 都能够按照原样没有差 错 地通过这个数
据链路层。 因 此， 对所传送的数据来说， 这些数据就 “ 看不见 “ 数据链路层有 什么妨碍数据
传输的东 西。 或者说， 数据链路层对这些数据来说是透明 的。

为了 解决透明 传输问题， 就 必须 设法使数据 中 可能出现的控制字符 “ SOH " 和 “ EOT "
在接收端 不被解释为控制字符。 具体的方法是 ： 发送端的数据链路层在数据中出 现控制字符
“ SOH ” 或 “ EOT " 的前 面 插 入 一个转 义 字 符 “ ESC " （其 十 六 进制 编 码 是 lB , 二 进制 是
00011 011)。 而 在接收端的数据链路层在把数据送往网络层之前删 除这个插入的转义字符。 这
种方法称为字节填充(byte stuffing)或字符填充( character
stuffing)。 如果转义字符也 出 现在数据
当 中， 那么解决方法仍然是在转义字符的前面插入一个转义字符。 因 此， 当接收端收到连续
的两 个转义字符时， 就删除其中前面的一个。 图 3-7 表示用字节填充法解决透明 传输的问题。

•  75  •

符

』

巾

』
三

,＇

字节填充 ，＇，

'，
，

， 三 ，

发 送
在 前

3. 差错检测

原 始 数据

三 I-ESC|

字节填充 ｝

字节填充＼

帧 结 束 符
｝

|SOHI

IEOT|

、
字节

填允

．

．勹二 厂曰

经过字节填 充 后 发送的数据

图 3-7 用 字 节填充法解决透 明 传输的 问 题

现实的通信 链路都不会是理想的。 这就是说 ， 比特在传输过程中可能会 产 生 差 错：
l 可
能会变成 O, 而 O 也 可 能变成 1 。 这就 叫 作 比特差错。 比特差错是传输差错中的一种。 本小节
所说的 ＂ 差 错 ＂ ， 如无特殊 说明 ， 就是指 “ 比特差错 ＂。 在一段时间内， 传输错误的比特 占 所
传输比特总数的比率称为误码率BER (Bit E r ror  Rate)。 例如， 误码率为10-1 0 时， 表示平均每
传送 101 0 个比特就会出现一个比特的差错。 误码率与 信 噪比有很大的关系。 如果设法提高信
噪比， 就 可以使误码率减小。 实际的通信 链路并非是理想的， 它 不可能使误码率下 降到零。
因 此， 为了 保证数据传输的可靠性 ， 在计算机网 络传输数据时 ， 必 须采用各种差错 检测 措 施。
目前在数据链路层广泛使用了 循环冗 余检验 CRC ( Cyclic Redundancy Check )的检错技术。

下 面我们通过一个简单的例子来说 明 循 环 冗 余检 验的原理。
在发送端 ， 先把数据划分为组 ， 假定 每组 k 个比特 。 现假定待传送的数据 M =  101001
( k  =  6 )。 CRC 运算就是在数据 M 的后 面添加供 差错检测用的 n 位 冗余码 ， 然后构成 一个
帧发送出去， 一共发送( k +  n)位。 在所要发送的数据后面增加 n 位的冗 余码 ， 虽然增大 了 数
据传输的开销 ， 但却 可以进 行 差错 检测。 当 传输可能出现差错时， 付出这种代价往往是很值
得 的。

这 n 位 冗 余码 可 用以下方法得 出 。 用二进制的模 2 运 算

＠进 行 2n 乘 M 的运算 ， 这相当
千在 M 后面添加 n 个 0。 得 到的( k +  n)位的数除 以收发双方事 先 商 定 的长度为( n + 1)位的除
数 P, 得 出商 是 Q 而余数是 R ( n 位 ， 比 P 少一 位 ）。 关千除数 P 下面还要介 绍 。 在图 3-8
所示的例子中， M =  1 01001
（ 即 k = 6 )。 假定除数 P =  1101 （ 即 n =3 )。 经模2 除法运算后
的结果是： 商 Q =  110101 （ 这个商并没有 什么用处 ） ， 而余数 R =  001。 这个余数 R 就作 为
冗 余码拼接在数据 M 的后面发送出去。 这种为了 进行检错而添加的冗 余码常称为帧检验序
（ 即2nM + FCS ) ,
列 FCS ( F rame Check  Sequen ce)。 因 此加上 FCS 后发送的帧是 1 01001001
共有( k + n)位。

顺便说 一下 ， 循环 冗余检验 CRC 和帧 检验序列 FCS 并不是同一个概念。 CRC 是一种
检错方法 ， 而 FCS 是添加在数据后面的冗 余码 ， 在检错方法上可以选用 CR C, 但 也可不选
用 CRC。

心 注 ： 用 模 2 运 算 进 行 加 法时不进位 ， 例 如 ，

1 1 1 1 + 1 0 1 0 = 0 1 0 1 。 减 法 和 加 法

一

样 ， 按加法规 则 计 算 。

•  76 •

1 1 0 1 0 1  -- Q（商）

P（除数）一 1 1 O l|10 1 0 010 00 - 2“

M （被除数）

1 1 0 1:::''
1 1 1 0: :
1 1 0 1:

0 1 1 1:

垒 ．

1 1 1 0
1 1 0 1

0 1 1 0
0 00 0

1 1 0 0
1 1 01

0 0 1  -- R（ 余 数 ）， 作为 FCS

图3- 8 说 明 循环冗余检验 原理的例 子

一

在接收端把接收到的 数据以 帧为单位进 行 CRC 检验 ： 把收到的每

个 帧都 除以同样的

除数 P（模 2 运 算）， 然后 检 查 得到的 余 数 R。

一

如 果在传输过程中 无差错， 那么 经过 CRC 检验后 得出的 余 数 R 肯定是 0（读者可以自

已验算

下。 被 除数现 在是 10 10 0 10 0 1 , 而 除数是 P =ll Ol, 看 余数 R是 否为 0 )。

但 如 果出 现误码， 那么 余 数 R仍等千 零的概率是 非常 非常 小的（这可以通过 不 太复杂

的概率计算 得出， 例如， 可参考[TANEll ]）。

一

总之， 在接收端 对收到的每

帧 经过 CRC 检验后， 有以 下两种情况 ：

一
(1) 若得出的 余数 R = O , 则 判定这个 帧没有差错， 就接 受(accept)。
(2) 若 余数 R

O , 则 判定这个 帧有差错（ 但 无法确定 究 竟是 哪

-=1=

位或 哪 几位出 现了差

错）， 就 丢 弃。
3  + x

2 +

一种较方 便的方 法是用多 项式来表示 循 环 冗 余 检 验过程。 在 上面的例 子中， 用多 项式

3

P(X) = X

1表示上 面的 除数 P = 110 1（最高位 对 应千 X

, 最低位 对 应于 炉）。 多 项式

P(X)称为 生 成 多 项式。 现在广泛使用的 生成多 项式 P(X)有以 下 几种 ：

= X

2

x

X
X
X
勹
气
3 2  + x
6 + x2
勹

2

CRC-16
CRC-CCITT =

x

+ 1
3 + x
气 X

5 +
22 +
l

CRC-32 =

x1勹X气 炉 ＋x1

x8

° +

+ x

7 +

+ x

2 + x +

5  +
x4

X

1

帧接
“

在数据链路层， 发送端 帧检验序列 FCS的 生成和接收端的 CRC 检验都是用硬件 完成的，

处理很 迅速， 因此并不 会 延 误数据的 传输。

从以上的 讨论不 难看出， 如 果 我们在传送 数据 时 不以 帧为单位来传送， 那么就 无法 加

入 冗 余码以进 行差错检验。 因此， 如 果要在 数据链路层进 行差 错检验， 就必须把 数据 划分为

一

一

一

帧， 每

一
帧都 加上冗 余码，

帧地传送， 然后在接收 方逐 帧进 行差错检验。

最后 再强调

下， 在数据链路层 若仅仅使用 循 环 冗 余检验 CRC差错检测技术， 则 只能
凡是接收端数据 链路层接 受的 帧 ， 我们 都能 以 非 常接近千 1
。 接收端 丢 弃的 帧 虽 然 曾 收 到 了， 但最 终 还

＂

的 概率认 为 这 些帧在传输过程 中 没 有产生差错

做到 对 帧的 无差错接受， 即 ：

”
是 因为有差错被 丢 弃， 即没有被接受。 以 上所述的可以 近似地表述为（通常都是这样 认为） ：

“凡是接收端数据 链路层接受的 帧均无差错

。

“

＂

请 注意， 我们现在 并没 有要 求 数据链路层 向网络层 提 供

”

可 靠传输

的服务。 所 谓

“可 靠传输

就是 ： 数据链路层的 发送端 发送什么， 在接收端就收到什么。 传输差错可分为

•  77  •

一

一

两 大类 ：

类就是 前面 所说的最基本的比特差错， 而另

类传输差错则更复杂 些， 这就是收

到的 帧并没有出 现比特差错， 但 却出 现了 帧丢失 、 帧重复或帧失序。 例如， 发送方连 续传送

一

三个 帧 ：

［＃ 1 ]-[#2]-[#3]。 假定接收端收到的每

个 帧都没有比特差错， 但 却出 现下面的 几种

情况 ：

帧丢 失 ： 收到 [#l ]-[#3 ]（ 丢 失 [#2]）。

帧重 复 ： 收到 [# 1 ]-[#2]-[ #2]-[ #3 ]（ 收到两个 [#2] )。

一

帧 失 序 ： 收到 [# 1 ]-[ #3 ]-[ #2]（后发送的 帧 反而先到达了接收端， 这与

一

般数据链路 层的

传输概念不

样）。

”

＂

“

＂

以上 三种情况都属千

出 现传输 差错

， 但都不是这 些 帧 里有

比特差 错

。 帧 丢 失很

容 易 理解。 但出 现帧重复和 帧 失序 的情况则较为复杂， 对这些 问 题我 们 现在 不 展开讨论。 在

学 完第 5章的 5 .4 节后， 我 们就 会 知道在什么情况下接收端可能会 出 现 帧重复或 帧 失序。

“

”

“

”

总之， 我们 应 当明确，

无比特差错

与

无传输差错

并 不是 同样的概念。 在数据链

路 层使用 CRC 检验， 能够实 现 无比特差错的传输， 但这 还 不是可 靠传输。

我 们 知道， 过去 OSI的 观 点是 ： 必须让数据链路 层向 上提供可 靠传输。 因此 在 CRC 检
错的基础上， 增 加了 帧编号、 确认和 重传机制。 收到 正确的 帧就要向发送端发送确 认。 发送

一

端 在

定的 期 限内 若没有收到 对 方的确 认， 就认为出 现了差错， 因 而就进行重传， 直到收到

对方的确 认为 止。 这种方法在 历 史上 曾 经 起到很好的作用。 但 现在的通信线路的 质量 已 经大

大 提高了， 由通信链路 质量不好 引 起 差 错的概率 已 经大 大 降低。 因此， 现在 互联网就 采取了

区别 对 待的方法 ：

对于通信 质量 良好的有线传输链路， 数据链路 层协议不使用确 认和重传机制， 即不要

求数据链路 层向上 提供可 靠传输的服务。 如 果在数据链路 层传输数据时出 现了差错并 且需要

进行 改 正， 那么 改正差错的任务就 由上 层协议 （例如， 运输 层的 TCP协议） 来 完成。

对千通信 质量较差的 无线传输链路， 数据链路 层协议使用确 认和重传机制， 数据链路

层向 上提供可 靠传输的服务（见 第 9章）。

实 践证明， 这样 做可 以提高通信 效率。

可 靠传输协议将在 第 5 章中讨论。 本章介绍的数据链路 层协议都不是可 靠传输的协议。

3.2  点对点协议 PPP

在通信线路 质量较 差的 年代， 在数据链路 层使用可 靠传输协议 曾 经是

种好 办法。 因
此， 能实 现可 靠传输的 高级数据 链路控制 HDLC (High-level Data Link Control)就成为当时比

较流行的数据链路 层协议。 但现在 HDLC 已很 少使用了。 对千 点对 点的链路， 简单 得 多的

点 对点 协议 PPP (Point-to-Point Protocol)则是目 前使用 得最广泛的数据链路 层协议。
3 .2. 1  PPP 协 议的特 点

一

我们 知道， 互 联网用户通常都要连接到某个 ISP 才能接入到 互 联网。 PPP协议就是用户

计算 机和 ISP进行通信时 所使用的数据链路 层协议（如图3-9 所示）。

•  78  •


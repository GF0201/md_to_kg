道的网络 气 其传播时延 和带 宽 都很大， 要获得高吞 吐率需要更大的窗口大小。

窗口扩大选项 占 3 字(cid:7194) ， 其中有一个字(cid:7194)表示移位值 S。 新的窗口值等千 TCP首部中
1 6 +  S )。 移位值 允 许使用的最大值是1 4 , 相当千窗口最大值增大

的窗口位数从1 6 增大到(
到 i l 6 + 1 4) _  l  =  230 _ 1 。

窗口扩大选项可以在双方初始建 立 TCP 连接时进行协 商。 如果连接的某 一 端 实现了窗

口扩大， 当它不再需要扩大其窗口时 ， 可发送 S = O 的选项， 使窗口大小 回到1 6。

时 间 戳选项 占 10 字(cid:7194) ， 其中最主要的字段是 时 间 戳值字段 (4 字(cid:7194)） 和时间戳 回 送 回

答字段 (4 字(cid:7194)）。 时间 戳选项有以下两个功(cid:7126)：

第 一 ， 用来 计算往返时间 RTT（见后 面的 5.6.2 (cid:7194) ）。 发送方在发送报文 段时把当前时

钟的时间值放入时间戳字段 ， 接收方在确认该报 文 段时把时间戳字段值复制到时间戳回送回

答字段。 因此， 发送方在收到 确认报文后 ， 可以准确 地计算出 RTT。

Agains t  Wrappe d  Se que nce  numbe rs

第 二 ， 用 于处理 TCP 序 号 超过 232 的情况 ， 这 又 称 为 防 止 序 号 绕 回 PAWS (Prote ct
)。 我们知道， TCP 报文 段的序 号只有 32位， 而每增加
232
个序 号 就会 重复使用原 来 用 过的序 号。 当使用高速网络时 ， 在一次 TCP连接的数据传送
中序 号很可(cid:7126)会 被 重 复使用。 例如， 当使用1 .5 Mbit/s 的速率发送报文 段时， 序 号重复要 6
小时以上。 但若用2 .5 Gbit/s 的速率发送报文 段 ， 则不到1 4 秒序 号就会 重复。 为了使接收方

(cid:7126)够把新的报文 段和迟到很久的报文段 区分开 ， 可以在报文 段中加上这种时间 戳。

我们将在后 面的5.6.3 (cid:7194) 介 绍 选择确认选项。

5. 6  TC P 可靠传输 的 实现

本(cid:7194)讨 论 TCP可 靠传输的实现。

我们首先 介 绍以字(cid:7188)为单位的滑 动 窗 口。 为了讲 述可靠传输 原理的方便 ， 我们假 定 数
据传输只在一个 方 向 进行 ， 即 A 发送数据 ， B 给出确认。 这样的好处是使讨 论 限千两个窗

口， 即发送方A 的发送窗口和接收方 B 的接收窗口。 如果再考虑 B 也向A 发送数据 ， 那 么

还要增加A 的接收窗口和 B 的发送窗口， 这样总 共有4 个都不断在变化 大小的窗口。 这 对

讲述可靠传输的原理并没有多少 帮 助 ， 反 而会使问题变得更加烦 琐。

5

．

6

l

以

字

为节

单

位

的

滑

动

口窗

、
、

c
p

T

,

的

滑

窗动

是口

以

字

(cid:7194)

为

位单

。的

为

了

便

说千

明

滑

动

窗

口

的

工

作

原

、

理

，

我

1
1

故

意

把

后

面

图

5

l
4

(cid:7169)

图

－

5

17

中

的

字

(cid:7188)

编

号

都

取

得

很

、

iJ

（

实

际

的

窗

小

多

为

数

千

字

(cid:7194)

儿

I
见

假

定

A

欠
4

到

了

B

发

来

的

石
角

认

报

文

段

，

其

中

窗

口

是

欠L

到
欠L

＿

下

个

字

(cid:7194)

序

号

是

31

（

请

注

的

＿

(cid:7172)
了
1

°）

根

据

这

两

数个

据

A

就

构

口

大
o
字

2

(cid:7194)

，

而

确

认

号

是

3

l
（

这

表

明

B

期

望

组

的

序

号

）

而

(cid:7172)

序
lj

号

3

O

为

止

的

数

据

已

经

送窗口， 如图 5-1 4 所 示。

CD 注 ： 这种信道常称为长粗管道(long fat pipe)。

扫 一扫

颖
二意

•  229  •

后，沿
厂一一—

字 节 的 尸 前 移
序 号

不 允许收缩 前，沿
X

令，

＞ 前移

- A 的发 送 窗 口 ＝ 20

直

气巴吓三三三三三三千卢尸

允 许发 送的序号

收 到 确 认

}

时 间

B 期 望
收到 的 序 号

图5- 14 根据B给 出 的 窗 口 值 ， A 构造 出 自 己的发送窗 口

我们先讨论发送方 A 的发送窗 口。 发送窗 口表示： 在 没有收到B 的确认的情 况 下，A
可 以连续把窗 口内 的数据 都发送出去。 凡 是 已 经发送过的数据 ， 在未收到确认之前都必须暂
时保 留 ， 以便 在超时重传时 使用。

发 送 窗 口里 面的序号表示允 许发送的序号。 显然， 窗 口越大， 发送方就 可 以 在收 到对
方确认之前连续发送 更 多 的数据 ， 因 而可能获得 更高的传 输 效 率。 在上 面的 5.5 节 我们 已经
讲过， 接收方会把自 己的接收 窗 口数值放 在窗 口字段中发送给对方。 因 此，A 的发送窗 口一
定 不能超过B的接收 窗 口数值。 在后 面的 5.8 节我们将 要讨论， 发送方的发送窗 口大小 还 要
受到当时网络 拥塞程度的制约。 但在目前， 我们暂 不考虑网络 拥塞的影 响 。

发送 窗 口后沿的后 面部分表 示 已发送且 已 收 到了确认。 这些 数据 显 然 不 需 要 再保 留 了。
示 不允 许发送， 因 为接收 方 没有为这部分数据 保 留 临时存 放的

而发送窗 口 前沿的前 面部分
缓存空间。

表

发送窗 口的位置 由窗 口前沿 和后沿的位置 共 同确 定。 发送 窗 口后沿的变 化情况 有 两种
可能， 即 不动 （ 没有收 到新的确认） 和 前移 （收到了 新的确认）。 发送窗 口后沿 不可能 向 后
移动， 因 为 不能撤销 掉已收 到的确认。 发送窗 口前沿 通常 是 不断 向 前移动的， 但也 有可能 不
动。 这 对 应 两种情况： 一 是 没有收到新的确认 ， 对方 通知的窗 口大小也 不变；二 是收到了新
的确认但对方 通知的窗 口缩小了， 使得发送窗 口前沿 正 好 不动。

发送窗 口前沿也 有可能向 后收缩。 这发 生 在对方 通知的窗 口缩小了。 但 TCP的标 准 强
烈 不赞成这样做。 因为很可能发送方 在收到这个通知 以前 已 经发送了窗 口中的许 多 数据 ， 现
在又 要收 缩 窗 口， 不让发送这些 数据 ， 这样就会产生一些错误。

现在假定A 发送了序号为 31 ~  41 的数据 。 这时， 发送窗 口位置 并未改变 （ 如图 5-15
所 示）， 但发送窗 口内 靠后面有 11个字节 （ 灰 色方框表示） 表示 已发送但未收到确认。 而发
送 窗 口内 靠前 面的 9个字节 （ 序号 42 ~ 50 ) 是 允 许发送但 尚未发送的。

------ A 的发 送 窗 口 位置 不 变

可用 窗 口

国画抇 畴 即栩醴畴酝 酰归 卢扫 匝

言 ［二二

＿＿tw

允 许发 送 但 尚 未发 送

回 回 日 回 回

不 允 许发 送

!3

回目回四回 回
已 发送 确认
并 交付主机

B 的 接 收 窗 口 ＝ 20

日 回 回 回 回 回 回 压 压 日 日 回 回 压 邑 网

回 回 日 回 召

允 许接 收

不 允 许接收

－ 时 间

图 5- 15 A 发送 了 l l 个字 节 的 数据

•  230  •

从以上所述可以看出， 要描述一个发送窗口的状态需要三个指针： P i , P2 和 P3（如图 5-1 5

所示）。 指针都指 向 字 (cid:7198)的序 号。 A 的发送窗口中三个指针指 向 的几个部分的意 义如下：

P 1 之前的数据（序 号 <31 ) 是 已发送并 已收到确认的部分。

P3 之后的数据（序 号＞ 50 ) 是 不允 许发送的部分。
P 1  =A 的发送窗口 ＝ 20 （序 号31 ~ 50 )。

P3

P2 - P ]
—

已发送但 尚 未收到 确认的字(cid:7198)数（序 号31 ~ 4 1

)。

P2  = 允 许 发 送但 当前 尚 未发送的字(cid:7198)数（序 号4 2~ 50 )（又称为可用 窗 口或有效窗

＝

P3

口 ）。

—

再看一下 B 的接收窗 口。 设 B 的接收窗 口大小是 20 。 在接收窗口外 面， 到 序 号 为 30
的数据是 已经发送过确认， 并且 已经交付主机了。 因此在 B 可以不再保 留 这 些数据。 接收
窗口内 的数据（序 号31 ~  50 ) 是 允 许接收的。 在图 5-1 5 中， B 收到 了序 号为32和33的数

据， 但序 号为31 的数据没有收到（也许 丢 失 了， 也许滞 留 在 网络中的某处）。 请 注 意 ， B 只

(cid:7126)对按序收到的数据中的最高序 号 给出确认， 因此 B 发送的确认报文 段中的确认号 仍然 是
31 （即 期 望收到的序 号）。

现在假定 B 收到了序 号为31 的数据， 把序 号 为31 ~ 33的数据交付主机， 删 除这 些数
据。 接着把接收窗口向前移 动 3个序 号（如图 5-1 6 所 示）， 同 时给 A 发送确认， 其中窗口

值仍为 20 , 但确认号 是 34。 这 表明 B 已经收到 了 到 序 号 33 为止的数据。 我们 注 意 到 ， B

还收到 了序 号 为37, 38 和40 的数据， 但这 些数据 都没有按序到达， 只(cid:7126) 先暂存在 接收窗口

中。 A 收到 B 的确认后 ， 就可以把发送窗口 向前滑 动 3个序 号 ， 但指针 P2 不动。 可以看出，

现在A 的可用窗口增大了些， 可发送的序 号 范 围是4 2~ 53。

送 窗 口一可 用 窗口 增 大

A 的

发

向 前滑动

酶酶匪拒l回即 劂 酮 即 唇 即 叩 回 硒 哑 哑归三三 国酰酰
t 已发送但未收到确认 t  允 许

收到确认

未发送

送但

送

并

已

尚

一］尸

发

P2

发

P3

P1

B 的接 收 窗 口 向 前滑动 -'”“'”

酶酶酶国三卫 1回 匾 回三王三三 回 回 回 回尸 回 回
收
不 允许
接

f f  t
三 允 许接

认 并 交 付主 机

送确

收

发

已

他

时 间

图5- 1 6 A 收到新的确 认号 ， 发送窗 口向前滑动

A 在 继 续发送完 序 号 4 2 ~  53 的数据后 ， 指针 贮 向前移动和 P3 重合。 发送窗口 内 的序

号 都 已用完， 但还没有再收到确认（ 如图 5-1 7 所 示）。 由千 A 的发送窗 口 已 满 ， 可用窗口

已 减小到 零 ， 因此必须停 止发送。 请 注 意 ， 存在下面这种可(cid:7126)性， 就是发送窗口 内 所有的数

据都 已 正 确到达 B, B 也早 已发出了确认。 但不幸的是 ， 所有这 些 确认都滞 留 在网络中。 在

没有收到 B 的确认时， 为了保证可靠传输， A 只(cid:7126)认为 B 还没有收到这 些数据。 千是 ， A
在经过一 段时间后 （由超时计时器控制） 就重传这 部分数据， 重新设置超时计时器， 直到收

到 B 的确认为止。 如果A 按序收到 落在发送窗口 内 的确认号， 那么A 就可以使发送窗口继

续向前滑 动 ， 并发送新的数据。

•  231 •

A 的发 送 窗 口 已满 ， 可 用 窗 口 为零

—. -P 、
回目回回回回回回 眶 圉 翻 翻 曝 圉 翻 圉 醒 固 圈 暇 圈 翻 圈 圈 圈圉 圈 圈 5 回 回
t言

_＿

～t、

达但未收到确 认

送 并 收 到 确 认

发

发

已

已

p l

图5- 1 7 A 的发送 窗 口 内 的序 号 都 属 于 已发送但 未 被 确 认

我们 在前 面的图 5-7 中 曾 给 出了这 样的概念： 发送方的应用进 程把字 节 流 写 入 TCP的
发送缓存， 接收 方的应用进 程从 TCP 的接收 缓存中读取字节流。 下面我们就进 一 步讨论前
面讲的窗 口和缓存的关 系。 图 5- 1 8 画 出了发送方维 持的发送缓存 和发送 窗 口， 以及 接收 方
维持的接收 缓 存 和 接收 窗 口。 这 里 首先 要 明确 两 点 ：

荨

TCP

最 后 写 入

I� 发送夕言的

发送窗口
- - - - - - - - ------ - - - - - - - - - - -----
'
'
'
'

字 节

t … …----------------t_＿＿＿： 一

最 后 被确 认
的字节

(a)

送

最 后

发
的字节

序 号增 大
r

时 间

发 送 缓 存 和

送 窗 口

发

荨

TCP

下

一

个 期 望 收 到 的 字 节
(b)

接收缓存和接收窗 口

口 时 间

图5- 1 8 TCP 的缓存和 窗 口 的关 系

第 一， 缓 存 空间和序号 空间都是 有限的， 并 且 都是 循环使用的。 最好 是把它 们画成圆

环状的。 但这 里为了 画图的方便， 我们还是把它 们画成了长条状的。

第二， 由于缓存或窗 口中实际的字节 数 可能 很大， 因此图 5- 1 8 仅 仅 是 个 示意 图，没有

标 出具体的数值。 但用这 样 的图来 说明缓 存 和发送窗 口以及 接收 窗 口的关 系 是 很清 楚的。

我们先看一 下图5-18(a)所 示的发送方 的情况。
发送缓存用来暂时存放：

( 1 ) 发送应用 程序传送给发送方 TCP准 备发送的数据；
(2)  TCP已发送 出但尚 未收到确认的数据 。
发送窗 口通常只是发送缓 存 的一部分。 已被确认的数据 应当从发送缓存 中删 除 ， 因此
发送缓 存 和发送窗 口的后沿是重合的。 发送应用程序最后写 入发送缓存的字节减去最后被确
认的字节， 就是还保 留 在发送缓存中的被 写 入的字节 数。 发送应用 程序必须 控制写入缓存的

速率， 不能太快， 否则发送缓存就会没有存放数据 的空 间。

再看一 下图5-l 8(b)所示的接收方的情况。
接收 缓存用来暂时存放：
( 1 ) 按 序到达的、 但尚 未被 接收 应用 程序读取的数据 ；
(2) 未按 序到达的数据 。
如果收 到的分组被检测 出 有差 错， 则要 丢 弃。 如果 接收 应用 程序来 不及读取 收到的数
据 ， 接收 缓存最终就会被 填 满 ， 使 接收 窗 口减小到零。 反之， 如果 接收 应用 程序能够及时
从 接收 缓存中读取收 到的数据 ， 接收 窗 口就可 以增大， 但最大 不能超 过 接收 缓存 的大小。

•  232  •

图5-18(b)中 还指出了下一 个 期 望 收到的字节 号 。 这 个字节 号 也就是接收 方给发送方的报文
段的首部中的确认号。

根据 以上所讨论的， 我们 还 要再强调以下 三点 。
第一， 虽 然A 的发送窗 口是根据 B的接收 窗 口设置的， 但在同一时刻，A 的发送窗 口
并 不总是和 B 的接收 窗 口一样大。 这 是因为通过网络传送窗 口值需要经 历 一 定的时间滞 后
（这 个时间是不确 定的）。 另 外， 正 如后面 5.7 节将 要讲到的， 发送方A 还可能根据 网络当
时的 拥塞情况适当减小 自 己的发送窗 口数值。

第二， 对 千 不按 序到达的数据 应 如何 处理， TCP标 准 并 无 明确规 定。 如果 接收 方把 不
按 序到达的数据 一 律 丢 弃， 那么 接收 窗 口的管理将会比较简 单， 但这 样做对网络资源的利用
不利 （ 因为发送方会重 复传送较 多 的数据 ）。 因此 TCP通常是把 不按 序到达的数据 先临时存
放 在 接收 窗 口 中， 等到字节流中所缺少的字节收到后， 再按序交 付上层的应用 进程。

第三， TCP 要求 接收 方必须 有累 积确认的功能， 这 样可 以减小传 输开销 。 接收 方 可 以
在合适的时候发送确认， 也可 以 在 自 己 有 数据 要发送时把确认信 息顺便捎 带上。 但请注意 两
点 。 一是接收 方 不应过分推迟发送确认， 否 则 会导致发送方 不必要的重传， 这 反而浪 费了网
络的资源。 TCP标准规 定， 确认推迟的时间 不应超过0.5 秒。 若收到一连串 具 有最大长度的
报 文 段， 则 必须每 隔 一 个报 文 段就发送一 个确认[RFC 1122,  STD3] 。 二是捎 带确认实际上
并 不经常发生， 因为大 多 数应用程序 很少同时 在 两 个方 向 上发送 数据 。

最后再强调一 下 ， TCP的通信是 全双 工 通信 。 通信中的每 一 方 都 在发送和接收 报 文 段。
因此， 每 一 方都 有 自 己的发送窗 口和 接收 窗 口。 在谈到这 些窗 口时， 一 定要 弄清是哪一方的
窗 口。

5 .6.2  超时重传 时 间 的 选 择

上面已经 讲到， TCP的发送方 在规 定的时间内 没 有收到确认就 要 重传已发送的报 文 段。

这种重传的概念是很简 单的， 但重传时间 的选择却是TCP最复杂 的问题之 一。

由千 TCP的下 层是互 联网环境， 发送的报 文 段可能只经过一 个 高速 率的局 域网， 也可
能经过多 个低速率的网络， 并 且每 个 IP数据 报所选择的 路由 还可能 不 同。 如果把超时重传

时间设置得太短， 就会引 起 很 多 报文 段的 不必要的重传， 使网络负荷增大。 但若把超时重传
时间设置得过长， 则 又 使网络的空 闲时间 增大， 降低了传输效率。

那么， 运输 层的超时计时器的超时重传时间究 竟 应设置为多 大呢？
TCP采用了 一种 自 适 应算法， 它记录 一 个报 文 段发出的时间 ， 以及收到相应的确认的
时间。 这 两 个时间之差就是报文段的往返时间 RTT。 TCP保 留 了RTT 的一 个加权平均往返
时间 RTTs （这 又称为平滑的往返时间， S 表示 Sm oothed。 因为进行的是加权平均， 因此得
出的结果更加平 滑 ）。 每 当 第一 次测量到RTT样本时，RT飞 值就取为所测 量到的RTT 样本
值。 但 以后每测 量到一 个新的RTT 样本， 就按 下式重新 计 算一 次RTTs :

新的RTTs  =  (1  - a)  x （ 旧 的RTTs) +  a  x （新的RTT 样本）

（5-4)

在上式中， 0 �  a <  1。 若 a 很 接近 千零， 表示新的 RT飞 值 和 旧 的 RT飞 值 相比变化
不大， 而对新的 RTT 样本影 响 不大 (RTT 值 更新较慢 ）。 若 选择 a 接近 千 1 , 则表示新的
RT飞 值 受新的RTT 样本的影 响 较大 (RTT 值 更新较快 ）。 已成为建议标准的RFC 6298 推荐
的 a 值为 1/8 , 即 0.125。 用这种方法得出的加权平均往返时间 RTTs 就 比测 量出的 RTT 值

•  233  •

更加平滑。

显然 ， 超时计时器设置的超 时 重 传 时 间 RTO ( Retrans mis

ionTime-Out )应略 大千上面得

出的加权平均往 返时间 RTTs。 RFC 6298 建 议 使用下 式计算 RTO :

RTO =  RTTs + 4  x  RTT0

( 5-5 )

而 RT吓 是 RTT 的偏差的加权平均值 ， 它 与 RT飞 和新的 RTT 样本之 差 有 关。 RFC
RT兀值取为测 量到的 RTT 样本值的一 半。 在

6298 建 议这样 计算 RTTo。 当第 一 次测 量时，

以后的测 量中 ， 则 使用下式计算加权平均的 RTT贮

新的 RTTO = (1  - P)  x （ 旧 的 RTT0)  + P x  I  RTT s - 新的 RTT样本 1

(5-6 )

这 里 p是个小于1 的系数， 它的推荐值是1 /4, 即0 .25。

上面所说的往返时间的测 量 ， 实现起 来相 当 复杂。 试看下面的例子。
如图 5- 1 9 所示 ， 发送出一个报文 段 ， 设定的重传时 间 到 了 ， 还没有收到确认， 千是重
传报文 段。 经过了一 段时间后 ， 收到 了确认报文段。 现在的问题是 ： 如何判定 此确认报文段
是对先 发 送 的报文段 的 确认 ， 还 是对后来重传 的报文段 的 确 认 ？ 由千重传的报文 段和原 来 的
报 文 段 完 全 一样 ， 因此源主机在收到确认后 ， 就无法做出正 确的判 断 ， 而正确 的判 断对确定

加权平均 RT飞 的值 关 系很大。

若收到 的确认是对重传报 文 段的确认 ， 但却 被源 主机 当 成是对原 来 的报 文 段的确认 ，

则 这样计算出的 RT飞 和超时重传时间 RTO 就 会 偏大。若后面再发送的报 文 段又是 经过重

传后才收到确认报 文 段 ， 则 按此方法得出的超时重传时间 RTO 就越 来 越长。

送 报 文段

发

l

一— 超时重传

重 传 报 文段

—l

/－—－ 任返

主
{
：三
？
TT

返 时 间 RTT？

l 、 收到 确认

时 间

一一

1

图 5 - 1 9 收 到 的 确 认 是 对 哪

个报文段 的 确 认 ？

一

同样 ， 若收到的确认是对原 来 的报文 段的确认， 但 被 当 成是对重传报文 段的确认 ， 则

由此计算出的 RT飞 和 RTO 都 会偏小。 这 就必然 导(cid:7175)报文段过多地重传。 这样就有可(cid:7126)使

RTO 越 来越短。

根据以上所述 ， Kam 提出了一个算法： 在计算加 权平均 RT几 时 ， 只 要报文段重传 了 ，

就不采 用 其往返时间样本 。 这样得 出 的 加 权平均 RT飞 和 RTO 就较准确 。

但是 ， 这 又 引 起新的问题。 设想出现这样 的情况： 报 文 段的时延 突 然 增 大 了很多。 因

此在原 来 得出的重传时间内 不会收到 确认报文 段 ， 千是就重传报文 段。 但根据 Kam 算法 ，

不考虑 重传的报文 段的往 返时间样本。 这样 ， 超时重传时间就无法更新。

因此要对 Kam 算法进行修 正。 方 法是 ： 报文段每重传一 次 ， 就把超时重传时间 RTO 增
大一 些。 典 型的做法是 取新的重传时间为 旧 的重传时间的 2倍。 当不再发生报 文 段的重传时 ，
才根据 上面给出的式( 5-5)计算超时重传时间。 实践证明， 这种策 略较为合理。

• 234

•

s
总 之， Kam 算法能够使运输 层区分开 有效的和无 效的往 返时间样本， 从而改进 了 往 返

时间的估 测， 使计算结果更加合理。

5 .6.3  选择确 认 SACK

现在 还 有一个问题 没 有讨 论 。 这 就是若 收到的报 文 段无差错， 只是未按 序号， 中间 还

缺少一些序号的数据 ， 那么能 否 设 法只传送缺少的数据 而 不重传 已 经 正确到达 接收 方的数据？

答 案是可 以的。 选择确认(SelectiveA CK)[RFC 2018, 建议标准］就是一种可行的 处理方法 。

我们用一个例子来 说明选择确认的工 作原理。 TCP的接收 方 在 接收 对方发送过来的数

据 字节 流的序 号 不连续， 结果就形成 了 一些 不连续的字节块（ 如图5-20 所 示） 。 可 以看出，
序号 1 ~ 1000 收到了， 但序号 1001 ~ 1500 没有收到。 接下来的字节 流又收到了 ， 可是又 缺
少 了 3001 ~  3500。 再后 面从序号 4501 起 又 没有收到。 也就是说， 接收 方收到了 和 前 面的字

节 流 不连续的 两个字节块。 如果这 些字节的序号都 在 接收 窗 口之 内 ， 那么 接收 方就先收 下这

些数据 ， 但要把这 些 信 息 准确地 告 诉发送方， 使发 送方 不要再重 复发送这 些 已 收到的数据 。

尸 － 连 续 的字 节 流 一寸

/二三�..．二 t.． ．］0 1

一

第

个 字节块

第 二 个 字 节块

确 认 号 ＝ 1 00 1

=

L 1

1 50 1

=

R 1

300 1  L 2

=

350 1

图 5-2 0 接 收到的 字 节 流 序 号 不 连 续

｀

4
斤

矗

。

4

5

＿

从图 5-20 可看出， 和前后字节 不连续的每一个字节块都 有 两个边界 ： 左边界 和右边界，
因此 在图中用四个指针标记这 些边界 。 请注意 ， 第一个字节块的左边界 L 1 =  1501, 但右边界
R i  =  3001 而 不是3000。 这 就是说， 左边界指出字节块的第一个字节的序号， 但右边界减 l 才
是字节块的最后一个序号。 同理， 第二个字节块的左边界 L2 = 3501, 而右边界 R2 = 4501 。

我们知道， TCP的首部 没 有哪个字段 能 够提供上述这 些字节块的边界信 息 。 RFC 20 1 8

规 定， 如果要 使用选择确认 SA CK , 那么 在建立 TCP连接时， 就要 在 TCP首部的选项中加
上 “ 允 许 SA CK " 的选项， 而双 方 必 须 都 事 先商 定好 。 如果 使用选择确认， 那么原来首 部中
的 “ 确认号字段 ” 的用法 仍然 不变 。 只是 以后在 TCP报 文 段的首 部中都增加了 SA CK 选项，
以便报 告 收到的 不连续的字节块的边界 。 由 千 首 部 选项的长度最多只有 40 字节， 而指明一

个边界就要用掉 4 字节 （ 因 为序号有 32 位， 需 要 使用 4个字节表 示）， 因此 在选项中最多 只
能指明 4 个字节块的边界 信 息 。 这 是因为 4 个字节块共 有 8个边界， 因 而需 要用 32 个字节
来描述。 另 外还 需 要 两 个字节， 一个字节用来指明是 SA CK 选项， 另 一个字节指明这个选
项要 占 用 多少字节 。 如果要 报 告 5 个字节块的边界信 息， 那么至少需 要 42 个字节 。 这 就超
过了选项长度 40 字节的上限 。 互联网建议标准 RFC 2018 还对报 告 这 些边界信 息的格式都

做出了非常 明确的规 定， 这 里从略 。

然 而， SA CK 文档 并 没有指明发 送方应当怎样响 应 SA CK 。 因此大多 数的实现 还是重传

所有未被确认的数据块。

•  235 •


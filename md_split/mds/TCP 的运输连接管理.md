续 排 队 ， 这 些 分组都将 排 在 队 列 的 尾部） 将 都 被 丢弃。 这 就叫作 尾 部 丢 弃 策 略 ( tail-drop

policy )。

路 由 器的尾部丢弃往往会 导 (cid:7175) 一 连 串 分组的丢 失 ， 这 就使发送方 出 现超 时重传， 使

TCP进入拥塞 控 制 的慢 开始状态， 结果使 TCP连接的发送方突 然 把数据的发送速率降低到

很小的数值 。 更为严重的是， 在网络 中 通常有很多的 TCP 连接（它们有不 同的源 点和终点 ），

这 些连接中的报文 段通常是复用在 网 络 层的 IP 数据报中传 送的。 在这种情况下， 若发生 了

路由器中的尾部丢弃， 就可(cid:7126) 会 同时影 响 到很多条 TCP连接， 结果使这 许多 TCP连接在 同

一 时 间 突 然 都进入到慢 开始状态 。 这 在 TCP 的术 语中称 为全 局 同 步( global

s ynchronization )。

全局 同 步使得全网的通信 量 突 然 下 降 了很多， 而在网络恢 复 正常后， 其通信 量 又 突 然 增大很

多。

为了避 免发生 网络中的全 局 同 步 现象， 在1 998 年 提 出了主动 队 列 管理 AQM (Active

Que ue  Manage me nt )。 所 谓 “ 主动

”

就是 不要等到 路 由 器的 队 列 长度 已经达到 最大值时才不

得不丢弃后面到达的分组。 这样就 太 被 动了。 应当在 队 列 长 度达到 某个值得警惕 的数值时

（即当网络拥 塞有了某 些拥 塞 征 兆 时 ）， 就主动丢弃 到达 的 分组。 这样就 提醒 了发送方放慢

发送的速率， 因而有可(cid:7126)使网络 拥 塞的程度减轻， 甚 (cid:7169) 不 出 现网络 拥 塞 。 AQM 可以有不 同

实现方法， 其中 曾 流行多年的就是 随机早期检测 RED ( Random  Early De te ction) o  RED还有

几个不 同的名 称， 如 Random Early Drop 或 Random Early Dis card（随机早 期丢弃 ）。

实现 RED 时需要使路由器维持两个参数， 即 队 列 长度 最小门限和最大门限 。 当每一个

分组到达时，

RED就按照规 定的算法先计算当前的平均队 列 长度。

(1 ) 若 平均 队 列 长度小于最小门限， 则 把新到达的分组放入队 列 进行排 队 。

( 2)若平均队列 长度超过最大门 限， 则 把新到达的分组丢弃。
(3 ) 若平均队 列 长度在最小门 限 和 最大门限之间， 则 按照某一 丢弃概率 p 把新到达的分

组丢弃 （ 这 就体现了丢弃分组的随机性 ）。

由此可见，

RED 不是 等 到 已经发生 网络拥 塞后才把所有在 队 列 尾部的分组全部丢弃，

而是 在检测 到 网络 拥 塞的早期征兆时（即 路由器的平均队 列 长度达到 一定数值时）， 就以概

率 p 丢弃个别 的分组， 让 拥 塞 控 制 只 在个别的 TCP连接 上进行， 因而避 免发生全 局 性的拥

塞 控制。

在 RED 的操作 中 ， 最难处理的就是丢弃概率 p 的选择， 因 为 p 并不是个常数。 对每一

个到达的分组， 都必须计算丢 弃 概率 p 的数值。 I ETF 曾 经推荐 在 互 (cid:7110) 网中的路 由 器使用

RED机制[ RFC 230 9]， 但多年的实 践证明，
公布的 RFC 756 7 已经把过去的 RFC 230 9 列 为 “ 陈 旧 的

RED的使用效果并不 太 理 想 。 因此， 在 201 5 年
＂， 并且不 再推荐使用 RED。 对路

由器进行主动 队 列 管理 AQM 仍是必要的。 AQM 实 际 上就是对路 由器中的分组排 队进行智

(cid:7126)管理， 而不是简单地把 队 列的尾部丢弃。 现在 已经有几种不 同的算法来 代 替 旧 的 RED, 但
都还在实验 阶段。 目前还没有一种算法(cid:7126)够成为I ETF 的标准， 读者 可注 意这 方面的进展。

5 . 9   TC P 的 运输连接管理

TCP是 面向连接的协 议 。 运输连接是 用来 传送 TCP报文的。 TCP运输连接的建立和释

•  246  •

放是每 一 次 面 向 连接的通信中必不可少的过程。 因此， 运输连接就 有三个阶段， 即 ： 连接建
立 、 数 据传送 和连接释放。 运输连接的管理就是使运输连接的建立 和释放都能 正常地进行。

在 TCP连接建立过程中 要解决 以 下 三个问题：
(1) 要 使每一方能够确知对方的存 在。
(2) 要 允 许双方协商 一些参 数 （ 如最大 窗 口 值 、 是否 使用窗 口扩 大 选项和时间戳 选项以

及 服务质 量等）。

(3) 能够 对运输实体资源 （ 如缓存 大小、 连接
TCP连接的建立采用客户 服务 器方式。 主动发起连接建立的应用进 程叫作 客户(client),

中的项目等） 进行分配。

表

而被动等待连接建立的应用进 程 叫 作服 务器(server)。

5 .9 . 1  TCP

的 连接建立

TCP建立连接的过程叫作 握手， 握 手 需 要 在客 户 和服务 器之间交换三

个 TCP报 文 段。 图5-28 画 出 了 三报 文 握 手 辽、建立 TCP连接的过程。

视 频 讲 解

客户. •
I

A

SYN­
SENT

！
ESTAB- i
LISHED

服 务 器

：

乏于三三三二＞
l
ESTAB- i
LISHED
i l
: : ----：:！: ： ： ： ： 二 ： ： ： ： ： ： ： ： ： ： ： ： ： 二 二 ： ： 二 ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ：？？、？亡之：“二 ： ：

l
,

图5-2 8 用三报 文握手建立 TCP 连接

假定主机A 运行的是 TCP客 户 程序， 而B运行 TCP服 务 器 程序。 最初 两端的 TCP进

程 都 处于 CLOSED （ 关 闭） 状 态。 图中在 主机下 面的方框 分别是 TCP进 程所处的状态。 请

注意 ， 在本例中，A主动打开连接， 而B被动打开连接。

一开始，B的 TCP服务 器进 程先创建传输控制块 TCB@， 准备 接受客户 进 程的连接请求。
然后服务 器进 程就 处千 LISTEN （收 听） 状 态， 等待 客 户 的连接请求。 如 有， 即做 出响 应。

CD 注 ： 三 报 文 握 手 是 本 教 材 首 次 采 用 的 译 名 。 在 RFC 793  ( TCP 标 准 的 文 档 ） 中 使 用 的 名 称 是 three way  handshake, 但 这
”

“

个 名 称 很难 译 为 准 确 的 中 文 。 例 如 ， 以 前 本 教 材 曾 采用

三次 握 手

这 个 广 为 流 行 的 译 名 。 其 实 这 是 在

次握手过程 中 交 换 了 三

一

个 报 文 ， 而 并 不 是 进 行 了 三 次握 手 （ 这 有 点 像 两 个 人 见 面 进 行

一

次握 手 时 ， 他 们 的 手 上 下 摇 晃 了 三 次 ， 但 这 并 非进 行 了 三 次 握
”

”

“

手 ） 。 最近再 次重新 阅 读 了 RFC 793 文 档 ， 发现有这样 的 表 述 ： “ three way  (three  message)  handshake

。 可见采 用

三报文握手

这 样 的 译 名 ， 在 意 思 的 表 达 上 应 当 是 比 较 准 确 的 。 请 注 意 ， handshake 使 用 的 是 单 数 而 不 是 复 数 ， 表 明 只 是

一

次握手 。

＠ 注 ： 传输控制 块 TCB (Transmission  Control  Block)存储 了 每

一

个 连接 中 的

一

些 重 要信 息 ， 如 ： TCP 连接 表 、 指 向 发送 和

接收缓存 的 指 针 、 指 向 重传 队 列 的 指 针 、 当 前 的 发送 和 接 收 序 号 ， 等 等 。

•  247  •

A 的 TCP 客 户 进程也是首先创 建传输控制块 TCB。 然 后 ， 在打算建 立 TCP 连接时， 向
B 发出连接请 求报文段， 这 时首部中的同 步位 SYN = l , 同 时选择 一个初始序 号 s
e q = x。
TCP规 定 ， SY N 报文段 （即 SY N = I 的报 文 段） 不(cid:7141)携 带数据， 但要消(cid:7108)掉一个序号。 这

时 ， TCP 客 户 进程进入 SYN -SEN T（ 同 步 已发送） 状 态。

B 收到 连接请求报文段后 ， 如 同 意 建立连接， 则向A 发送确认。 在确认报文 段中应把

SYN 位和 ACK 位 都置 l ， 确认号是 ack = x  + 1 , 同 时也为 (cid:7151) 己选择 一个初始序 号 s
e q = y。
请 注 意 ， 这个报 文 段 也不(cid:7126)携 带数据， 但 同样要消(cid:7108)掉一个序号。 这 时 TCP 服 务 器进程进
入 SYN- RCVD（ 同 步 收到） 状态。

TCP 客 户 进程收到 B 的 确认后， 还要向 B 给出确认。 确认报文段的 ACK 置 l ， 确认号

ack = y +  I , 而 (cid:7151) 己的序 号 s
果不携带数据则 不消(cid:7108)序号， 在这种情况下， 下一个数据报文段的序 号 仍是 s
时， TCP连接 已 经 建 立 ， A 进入 ESTABLI SHED（ 已 建立 连接） 状 态。

e q = x + 1 。 TCP的标准 规定 ， ACK 报 文段可以携 带 数据。 但如

e q = x + 1 。 这

当 B 收到 A 的确认后 ， 也进入 ESTABLI SH ED状态。

上面给出的连接建立过程叫作三报文握手。 请 注 意 ， 在图 5- 28 中 B 发送给A 的报文 段 ，

也可拆成两个报文 段。 可以先发送一个确认报 文 段 ( ACK = l , ack = x +  1)， 然 后 再发送一
个 同 步 报 文 段 ( SY N = 1 ,

e q  = y) 。 这样的过程就变成了 四 报 文 握 手 ， 但效果是 一样的。

 s

为什么A 最后 还要发送一次确认呢？ 这 主要是 为了防止 已 失效的连接请 求 报 文 段 突 然

又传送到了 B , 因(cid:7100) 产 生 错误。

所谓 “

已 失效的连接请求报文段

”

是 这样产 生的。 考 虑 一种正常情况， A 发出连接请求 ，

但因连接请 求报 文 丢 失而未 收到 确认。 千是 A 再重传一次连接请求。 后 来 收到了确认， 建
立了连接。 数据传输完 毕后， 就 释放了连接。A 共发送了两个连接请求报文段， 其中第 一个
丢 失 ， 第 二个到达了 B , 没有

“ 已 失效的连接请求报文段

”。

现假定出现 一种 异 常情况， 即 A 发出的第 一个连接请求 报 文 段 并没有丢 失 ， 而是 在某
些网络(cid:7188)点长时间滞 留 了， 以(cid:7175)延 误 到连接释放以后的某个时间才到达 B。 本来 这 是 一个早
已 失效的报文 段。 但 B 收到此失效的连接请 求报文段 后 ， 就误认为是 A 又发 出 一次新的连
接请 求。 于是就向 A 发出确认报 文段， 同 意 建 立 连接。 假 定不采用报文握手， 那么只 要 B

发出确认， 新的连接就建立了。

由 于现在 A 并没有发出建立连接的请求， 因此不会理睬 B 的确认， 也不会向 B 发送数
据。 但 B 却以为新的运输连接 已 经 建 立了， 并 一直等待 A 发来 数据。 B 的许多资 源就这样
白 (cid:7178) 浪 费了。

采用三报文握手的办法， 可以防 止上述现象的发生。 例如在刚 才的异常情况下 ， A 不会

向 B 的确认发出确认。 B 由千 收不到 确认， 就知道A 并没有要求 建 立 连接。

5 .9.2  TCP

的 连接释放

TCP 连接 释放过程比较复杂， 我 们 仍结 合 双 方状 态的改变来 阐 明连接

释 放的过程。

数据 传 输结束 后 ， 通信 的双方都可 释放连接。 现 在 A 和 B 都处于

ESTABLISHED 状态（如图 5-2 9 所示）。 A 的应用进程先向其 TCP 发出连

视狗讲解

接释放报文 段 ， 并 停 止再发送数据， 主动 关 闭 TCP 连接。 A 把连接释放报文 段首部的终止

•  24 8  •

控 制位 FI N 置1, 其 序 号 s

e q = u, 它 等 千前面 已传送 过的数据的最后一个字(cid:7192)的序 号 加1 。
这 时 A 进入 FI N -WAI T- I （ 终止 等 待 l ) 状 态 ， 等 待 B 的确认。 请 注 意 ， TCP 规定 ， FI N
报 文 段即 使不 携 带数据 ， 它 也 消 (cid:7107) 掉 一 个 序 号 。

客 户

三A

STAB- i
SHED  j ?

： ： ： ： 二 ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ： ：

i(  三 ESTAB- I  迪 知
,i ;:

ESTAB- :

服 务 器

FIN-
l
WAIT-1  j i

—习�

_｀＇ ＿ ,  seq二兰� CLOSE- i
WAIT
寸，心芯加"~心＇，心~泌心｀｀， ＄

u + \  ＿ ＿

l ！ 被 动 关 闭

LAS

1

图 5-29 TCP 连接释 放 的 过程

B 收到 连接释放报文 段后即发出确 认 ， 确 认 号 是 ack =  u  +  I , 而这个报文 段 (cid:7164) 己的序 号
是 V , 等 千 B 前面 已 传 送过的数据的最 后 一 个字(cid:7188)的序 号 加 l 。 然 后 B 就进入C LOSE­
WAIT（ 关 闭 等 待） 状 态 。 TCP服 务器进程这 时应通知高 层应用 进程， 因而从A 到 B 这个方

向 的连接就释放了 ， 这 时的 TCP 连接处千半 关 闭(half-clos

e )状 态 ， 即 A 已经没有数据要发

送了 ， 但 B若发送数据 ， A 仍要接 收。 也就是说 ， 从 B 到 A 这个方 向 的连接并 未 关 闭 ， 这
个状态 可(cid:7126)会 持 续 一段时间。

A 收到 来 (cid:7149) B 的确认后 ， 就进入 F IN-WAI T-2（ 终止 等 待 2) 状态 ， 等 待 B 发出的连接

释放报文 段 。

若 B 已经没有要 向 A 发送的数据 ， 其应用进程 就通知 TCP释放连接。 这时 B 发出的连
接释放报文 段必须使 FI N =1 。 现假定 B 的序 号 为 w （ 在 半 关 闭 状 态 B 可(cid:7126) 又发送了一 些数
据）。 B 还必须重 复 上次 已发送过 的 确认号 ack =  u  +  l 。 这 时 B 就进入 LAST-AC K（ 最后 确

认） 状 态 ， 等 待A 的确认。

A 在收到 B 的连接释放报文 段 后 ， 必 须 对此发 出 确 认 。 在 确认报文 段中把AC K 置 l,

确认号 ack =  w  + 1, 而 (cid:7163) 己的序 号是 s eq = u  +  I
（ 根据 TCP标准 ， 前面发送过的 FI N 报 文
段要消 (cid:7107) 一个序 号）。 然后进入到 TI ME-WAIT（ 时间 等 待 ） 状 态 。 请注 意 ， 现在 TCP 连接

还没有释放掉。 必须经过时间等待计时器(TI ME-WAIT timer)设置的时间 2MSL 后 ， A 才进

入到C LOSED 状 态 。 时间 MSL 叫作最长报文段寿命( Maximum Se gme nt Life time

),  RFC  793

建 议设为2 分钟。 但 这 完 全是从工程上来考虑的， 对 于 现在的网络 ， MSL =2 分钟可(cid:7126)太长
了一 些 。 因此 TCP允许不 同的实现可根据 具 体情况使 用 更小的 MSL 值。 因此， 从 A 进入
到 TIME-WAI T 状 态后 ， 要经过 4 分钟才 (cid:7141)进入到 CLOSED 状 态 ， 才(cid:7126)开始建立下一个新

•  249  •

的连接。 当 A 撤销相 应的传输控制块 TC B后 ， 就结束了这 次的 TCP连接。

为什么A 在 TI ME-WAI T 状 态 必 须 等 待2 MSL 的时间呢？ 这有两个理由。
第 一 ， 为 了 保证 A 发送的最后一个AC K 报文 段(cid:7126)够到达 B 。 这个AC K 报文 段有可(cid:7126)

丢 失 ， 因而使处在 LAST-AC K 状态的 B 收不到对 已发送的 FI N + AC K 报文 段的确认。 B 会

超时重传这个 FI N +AC K 报文 段 ， 而A 就(cid:7126)在2 MSL 时间 内 收到 这个重传的 FIN +AC K 报
文 段 。 接着 A 重传 一 次 确认 ， 重 新 启 动 2 MSL 计时器。 最后 ， A 和 B 都 正 常进入到
C LOSED 状 态 。 如果 A 在 TI M E-WAIT 状态不等待 一段时间， 而是在发送完AC K 报文 段后
立 即 释放连接 ， 那么就无法收到 B 重传的 FI N + AC K 报文 段 ， 因 而也不会 再 发 送一 次确认

报文段。 这样 ， B 就 无法按照正 常步骤进入C LOSED 状 态 。
第 二 ， 防 止 上 一 (cid:7194) 提到的 ” 已 失 效的连接请求报文段

出 现在本连接中 。 A 在发送完最
后 一个 AC K 报 文 段后 ， 再经过时间 2 MSL, 就可以使本连接 持续的时间 内 所 产 生的所有报
文 段 都 从 网 络 中 消 失。 这样就可 以使下 一个新 的 连接中不 会 出 现这种 旧 的连接请求报 文段。

”

B 只 要 收 到 了 A 发 出 的确认， 就进入C LOSED 状 态。 同 样 ， B 在撤销 相 应 的传输控

制块 TC B 后 ， 就结 束了这 次的 TC P 连接。 我 们 注 意 到 ， B 结束 TCP连接的 时 间 要 比 A 早

一 止匕

=· °

上 述的 TCP连 接释放过程是 四 报 文 握 手 。
除 时间等 待 计 时 器外 ， TCP还 设 有 一个保 活计 时器( ke e pal ive time r)。 设 想 有 这 样 的情况：

客 户 已 主 动 与 服 务 器 建 立 了 TCP 连接。 但后来 客 户 端的主 机 突 然出故 障。 显 然 ， 服 务 器以

后 就 不(cid:7126)再 收 到 客 户 发来的数据。 因 此 ， 应 当有措 施使服 务器不要再 (cid:7179) (cid:7180) 等 待下去。 这 就是
使用 保 活 计时器。 服 务器每 收到 一 次 客 户 的数据 ， 就重新设置保 活计时器 ， 时间的设置通常
是 两 小时。 若 两 小 时没有收到 客 户 的数据 ， 服 务器就发送 一个探 测 报 文 段 ， 以后 则 每隔 75
秒 钟 发送一 次。 若 一 连 发送 I O 个探测 报 文段后仍 无 客 户 的响 应 ， 服 务器就认为 客 户 端出了

故 障 ， 接 着 就 关 闭 这个连接。

5 . 9 . 3   TCP

的 有 限状态机

才-1 一主 I

为了更 清 晰 地看 出 TCP 连接 的 各种状态 之间的关 系 ， 图 5-30 给 出 了
TCP的有 限 状 态 机。 图中每 一个方框 是 TCP可(cid:7126)具有的状 态 。 每个方框中

的大 写 英 文字符串 是 TCP标 准 所 使 用 的 TCP连接状 态 名 。 状态 之间的箭 头

视 抑 讲 解

表 示 可 (cid:7131)发生 的 状 态 变迁。 箭 头 旁边 的 字 ， 表 明 引 起这 种 变迁 的 原 因 ， 或表 明 发生 状 态 变 迁

后 又 出 现什 么 动 作 。 请注 意图中有 三 种 不 同 的箭 头。 粗 实 线 箭 头 表示对客 户 进程 的 正常变迁。
粗 虚 线 箭 头 表示对服 务 器进程的 正常变迁。 另 一种细线箭 头 表 示 异 常变迁。

我 们 可 以 把 图 5-30 和前面的 图 5-2 8 、 图 5-2 9 对照起来 看 。 在 图 5-2 8 和图 5-2 9 中左边

客 户 进程 从上 到 下 的状态变迁 ， 就是 图 5-30 中粗实线箭 头 所指 的 状态变迁。 而在图 5-2 8 和

5-2 9 右边服 务 器进程 从 上到下的状 态 变 迁 ， 就是 图 5-30 中粗虚 线 箭 头 所指的状 态变迁。

还 有 一 些状态变迁 ， 例 如连接建立过程中的从 LI STEN 到 SY N -SE N T 和 从 SY N -SE N T

到 SY N -RC VD。 读 者 可分析 在 什么情 况 下 会出现这 样的变迁（见 习题 5-43)。

• 2 50

•


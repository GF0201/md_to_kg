道的网络气其传播时延和带宽都很大，要获得高吞吐率需要更大的窗口大小。
窗口扩大选项占3字(cid:7194)，其中有一个字(cid:7194)表示移位值S。新的窗口值等千TCP首部中
16+S)。移位值允许使用的最大值是14,相当千窗口最大值增大的窗口位数从16增大到(
到il6+14)_l=230_1。
窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=O的选项，使窗口大小回到16。
时间戳选项占10字(cid:7194)，其中最主要的字段是时间戳值字段(4字(cid:7194)）和时间戳回送回答字段(4字(cid:7194)）。时间戳选项有以下两个功(cid:7126)：第一，用来计算往返时间RTT（见后面的5.6.2(cid:7194)）。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT。
AgainstWrappedSequencenumbers第二，用于处理TCP序号超过232的情况，这又称为防止序号绕回PAWS(Protect
)。我们知道，TCP报文段的序号只有32位，而每增加
232
个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送
中序号很可(cid:7126)会被重复使用。例如，当使用1.5Mbit/s的速率发送报文段时，序号重复要6
小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒序号就会重复。为了使接收方(cid:7126)够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。
我们将在后面的5.6.3(cid:7194)介绍选择确认选项。
5.6TCP可靠传输的实现本(cid:7194)讨论TCP可靠传输的实现。
我们首先介绍以字(cid:7188)为单位的滑动窗口。为了讲述可靠传输原理的方便，我们假定数
据传输只在一个方向进行，即A发送数据，B给出确认。这样的好处是使讨论限千两个窗口，即发送方A的发送窗口和接收方B的接收窗口。如果再考虑B也向A发送数据，那么还要增加A的接收窗口和B的发送窗口，这样总共有4个都不断在变化大小的窗口。这对讲述可靠传输的原理并没有多少帮助，反而会使问题变得更加烦琐。
5．6l以字为节单位的滑动口窗、
、c
pT,的滑窗动是口以字(cid:7194)为位单。的为了便说千明滑动窗口的工作原、理，我1
1故意把后面图5l
4(cid:7169)图－517中的字(cid:7188)编号都取得很、iJ（实际的窗小多为数千字(cid:7194)儿I
见假定A欠
4到了B发来的石
角认报文段，其中窗口是欠L到
欠L＿下个字(cid:7194)序号是31（请注的＿(cid:7172)
了
1°）根据这两数个据A就构口大
o
字2(cid:7194)，而确认号是3l
（这表明B期望组的序号）而(cid:7172)序
lj号3O为止的数据已经送窗口，如图5-14所示。
CD注：这种信道常称为长粗管道(longfatpipe)。
扫一扫颖
二意•229•后，沿
厂一一—字节的尸前移
序号不允许收缩前，沿
X令，＞前移-A的发送窗口＝20直气巴吓三三三三三三千卢尸允许发送的序号收到确认}时间B期望
收到的序号图5-14根据B给出的窗口值，A构造出自己的发送窗口我们先讨论发送方A的发送窗口。发送窗口表示：在没有收到B的确认的情况下，A
可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂
时保留，以便在超时重传时使用。
发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对
方确认之前连续发送更多的数据，因而可能获得更高的传输效率。在上面的5.5节我们已经
讲过，接收方会把自己的接收窗口数值放在窗口字段中发送给对方。因此，A的发送窗口一
定不能超过B的接收窗口数值。在后面的5.8节我们将要讨论，发送方的发送窗口大小还要
受到当时网络拥塞程度的制约。但在目前，我们暂不考虑网络拥塞的影响。
发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。
示不允许发送，因为接收方没有为这部分数据保留临时存放的而发送窗口前沿的前面部分
缓存空间。
表发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种
可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口后沿不可能向后
移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动的，但也有可能不
动。这对应两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了新
的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。
发送窗口前沿也有可能向后收缩。这发生在对方通知的窗口缩小了。但TCP的标准强
烈不赞成这样做。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现
在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。
现在假定A发送了序号为31~41的数据。这时，发送窗口位置并未改变（如图5-15
所示），但发送窗口内靠后面有11个字节（灰色方框表示）表示已发送但未收到确认。而发
送窗口内靠前面的9个字节（序号42~50)是允许发送但尚未发送的。
------A的发送窗口位置不变可用窗口国画抇畴即栩醴畴酝酰归卢扫匝言［二二＿＿tw允许发送但尚未发送回回日回回不允许发送!3回目回四回回
已发送确认
并交付主机B的接收窗口＝20日回回回回回回压压日日回回压邑网回回日回召允许接收不允许接收－时间图5-15A发送了ll个字节的数据•230•从以上所述可以看出，要描述一个发送窗口的状态需要三个指针：Pi,P2和P3（如图5-15所示）。指针都指向字(cid:7198)的序号。A的发送窗口中三个指针指向的几个部分的意义如下：P1之前的数据（序号<31)是已发送并已收到确认的部分。
P3之后的数据（序号＞50)是不允许发送的部分。
P1=A的发送窗口＝20（序号31~50)。
P3P2-P]
—已发送但尚未收到确认的字(cid:7198)数（序号31~41)。
P2=允许发送但当前尚未发送的字(cid:7198)数（序号42~50)（又称为可用窗口或有效窗＝P3口）。
—再看一下B的接收窗口。设B的接收窗口大小是20。在接收窗口外面，到序号为30
的数据是已经发送过确认，并且已经交付主机了。因此在B可以不再保留这些数据。接收
窗口内的数据（序号31~50)是允许接收的。在图5-15中，B收到了序号为32和33的数据，但序号为31的数据没有收到（也许丢失了，也许滞留在网络中的某处）。请注意，B只(cid:7126)对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是
31（即期望收到的序号）。
现在假定B收到了序号为31的数据，把序号为31~33的数据交付主机，删除这些数
据。接着把接收窗口向前移动3个序号（如图5-16所示），同时给A发送确认，其中窗口值仍为20,但确认号是34。这表明B已经收到了到序号33为止的数据。我们注意到，B还收到了序号为37,38和40的数据，但这些数据都没有按序到达，只(cid:7126)先暂存在接收窗口中。A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了些，可发送的序号范围是42~53。
送窗口一可用窗口增大A的发向前滑动酶酶匪拒l回即劂酮即唇即叩回硒哑哑归三三国酰酰
t已发送但未收到确认t允许收到确认未发送送但送并已尚一］尸发P2发P3P1B的接收窗口向前滑动-'”“'”酶酶酶国三卫1回匾回三王三三回回回回尸回回
收
不允许
接fft
三允许接认并交付主机送确收发已他时间图5-16A收到新的确认号，发送窗口向前滑动A在继续发送完序号42~53的数据后，指针贮向前移动和P3重合。发送窗口内的序号都已用完，但还没有再收到确认（如图5-17所示）。由千A的发送窗口已满，可用窗口已减小到零，因此必须停止发送。请注意，存在下面这种可(cid:7126)性，就是发送窗口内所有的数据都已正确到达B,B也早已发出了确认。但不幸的是，所有这些确认都滞留在网络中。在没有收到B的确认时，为了保证可靠传输，A只(cid:7126)认为B还没有收到这些数据。千是，A
在经过一段时间后（由超时计时器控制）就重传这部分数据，重新设置超时计时器，直到收到B的确认为止。如果A按序收到落在发送窗口内的确认号，那么A就可以使发送窗口继续向前滑动，并发送新的数据。
•231•A的发送窗口已满，可用窗口为零—.-P、
回目回回回回回回眶圉翻翻曝圉翻圉醒固圈暇圈翻圈圈圈圉圈圈5回回
t言_＿～t、达但未收到确认送并收到确认发发已已pl图5-17A的发送窗口内的序号都属于已发送但未被确认我们在前面的图5-7中曾给出了这样的概念：发送方的应用进程把字节流写入TCP的
发送缓存，接收方的应用进程从TCP的接收缓存中读取字节流。下面我们就进一步讨论前
面讲的窗口和缓存的关系。图5-18画出了发送方维持的发送缓存和发送窗口，以及接收方
维持的接收缓存和接收窗口。这里首先要明确两点：荨TCP最后写入I�发送夕言的发送窗口
-----------------------------
'
'
'
'字节t……----------------t_＿＿＿：一最后被确认
的字节(a)送最后发
的字节序号增大
r时间发送缓存和送窗口发荨TCP下一个期望收到的字节
(b)接收缓存和接收窗口口时间图5-18TCP的缓存和窗口的关系第一，缓存空间和序号空间都是有限的，并且都是循环使用的。最好是把它们画成圆环状的。但这里为了画图的方便，我们还是把它们画成了长条状的。
第二，由于缓存或窗口中实际的字节数可能很大，因此图5-18仅仅是个示意图，没有标出具体的数值。但用这样的图来说明缓存和发送窗口以及接收窗口的关系是很清楚的。
我们先看一下图5-18(a)所示的发送方的情况。
发送缓存用来暂时存放：(1)发送应用程序传送给发送方TCP准备发送的数据；
(2)TCP已发送出但尚未收到确认的数据。
发送窗口通常只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此
发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确
认的字节，就是还保留在发送缓存中的被写入的字节数。发送应用程序必须控制写入缓存的速率，不能太快，否则发送缓存就会没有存放数据的空间。
再看一下图5-l8(b)所示的接收方的情况。
接收缓存用来暂时存放：
(1)按序到达的、但尚未被接收应用程序读取的数据；
(2)未按序到达的数据。
如果收到的分组被检测出有差错，则要丢弃。如果接收应用程序来不及读取收到的数
据，接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时
从接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。
•232•图5-18(b)中还指出了下一个期望收到的字节号。这个字节号也就是接收方给发送方的报文
段的首部中的确认号。
根据以上所讨论的，我们还要再强调以下三点。
第一，虽然A的发送窗口是根据B的接收窗口设置的，但在同一时刻，A的发送窗口
并不总是和B的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后
（这个时间是不确定的）。另外，正如后面5.7节将要讲到的，发送方A还可能根据网络当
时的拥塞情况适当减小自己的发送窗口数值。
第二，对千不按序到达的数据应如何处理，TCP标准并无明确规定。如果接收方把不
按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用
不利（因为发送方会重复传送较多的数据）。因此TCP通常是把不按序到达的数据先临时存
放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
第三，TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以
在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两
点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网
络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的
报文段，则必须每隔一个报文段就发送一个确认[RFC1122,STD3]。二是捎带确认实际上
并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。
最后再强调一下，TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。
因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清是哪一方的
窗口。
5.6.2超时重传时间的选择上面已经讲到，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。
这种重传的概念是很简单的，但重传时间的选择却是TCP最复杂的问题之一。
由千TCP的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可
能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同。如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传
时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。
那么，运输层的超时计时器的超时重传时间究竟应设置为多大呢？
TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的
时间。这两个时间之差就是报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返
时间RTTs（这又称为平滑的往返时间，S表示Smoothed。因为进行的是加权平均，因此得
出的结果更加平滑）。每当第一次测量到RTT样本时，RT飞值就取为所测量到的RTT样本
值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs:新的RTTs=(1-a)x（旧的RTTs)+ax（新的RTT样本）（5-4)在上式中，0�a<1。若a很接近千零，表示新的RT飞值和旧的RT飞值相比变化
不大，而对新的RTT样本影响不大(RTT值更新较慢）。若选择a接近千1,则表示新的
RT飞值受新的RTT样本的影响较大(RTT值更新较快）。已成为建议标准的RFC6298推荐
的a值为1/8,即0.125。用这种方法得出的加权平均往返时间RTTs就比测量出的RTT值•233•更加平滑。
显然，超时计时器设置的超时重传时间RTO(RetransmisionTime-Out)应略大千上面得出的加权平均往返时间RTTs。RFC6298建议使用下式计算RTO:RTO=RTTs+4xRTT0(5-5)而RT吓是RTT的偏差的加权平均值，它与RT飞和新的RTT样本之差有关。RFC
RT兀值取为测量到的RTT样本值的一半。在6298建议这样计算RTTo。当第一次测量时，以后的测量中，则使用下式计算加权平均的RTT贮新的RTTO=(1-P)x（旧的RTT0)+PxIRTTs-新的RTT样本1(5-6)这里p是个小于1的系数，它的推荐值是1/4,即0.25。
上面所说的往返时间的测量，实现起来相当复杂。试看下面的例子。
如图5-19所示，发送出一个报文段，设定的重传时间到了，还没有收到确认，千是重
传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：如何判定此确认报文段
是对先发送的报文段的确认，还是对后来重传的报文段的确认？由千重传的报文段和原来的
报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定加权平均RT飞的值关系很大。
若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认，则这样计算出的RT飞和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间RTO就越来越长。
送报文段发l一—超时重传重传报文段—l/－—－任返主
{
：三
？
TT返时间RTT？
l、收到确认时间一一1图5-19收到的确认是对哪个报文段的确认？
一同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则由此计算出的RT飞和RTO都会偏小。这就必然导(cid:7175)报文段过多地重传。这样就有可(cid:7126)使RTO越来越短。
根据以上所述，Kam提出了一个算法：在计算加权平均RT几时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均RT飞和RTO就较准确。
但是，这又引起新的问题。设想出现这样的情况：报文段的时延突然增大了很多。因此在原来得出的重传时间内不会收到确认报文段，千是就重传报文段。但根据Kam算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。
因此要对Kam算法进行修正。方法是：报文段每重传一次，就把超时重传时间RTO增
大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，
才根据上面给出的式(5-5)计算超时重传时间。实践证明，这种策略较为合理。
•234•s
总之，Kam算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。
5.6.3选择确认SACK现在还有一个问题没有讨论。这就是若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？
答案是可以的。选择确认(SelectiveACK)[RFC2018,建议标准］就是一种可行的处理方法。
我们用一个例子来说明选择确认的工作原理。TCP的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块（如图5-20所示）。可以看出，
序号1~1000收到了，但序号1001~1500没有收到。接下来的字节流又收到了，可是又缺
少了3001~3500。再后面从序号4501起又没有收到。也就是说，接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。
尸－连续的字节流一寸/二三�..．二t.．．］01一第个字节块第二个字节块确认号＝1001=L11501=R13001L2=3501图5-20接收到的字节流序号不连续｀4
斤矗。
45＿从图5-20可看出，和前后字节不连续的每一个字节块都有两个边界：左边界和右边界，
因此在图中用四个指针标记这些边界。请注意，第一个字节块的左边界L1=1501,但右边界
Ri=3001而不是3000。这就是说，左边界指出字节块的第一个字节的序号，但右边界减l才
是字节块的最后一个序号。同理，第二个字节块的左边界L2=3501,而右边界R2=4501。
我们知道，TCP的首部没有哪个字段能够提供上述这些字节块的边界信息。RFC2018规定，如果要使用选择确认SACK,那么在建立TCP连接时，就要在TCP首部的选项中加
上“允许SACK"的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中
的“确认号字段”的用法仍然不变。只是以后在TCP报文段的首部中都增加了SACK选项，
以便报告收到的不连续的字节块的边界。由千首部选项的长度最多只有40字节，而指明一个边界就要用掉4字节（因为序号有32位，需要使用4个字节表示），因此在选项中最多只
能指明4个字节块的边界信息。这是因为4个字节块共有8个边界，因而需要用32个字节
来描述。另外还需要两个字节，一个字节用来指明是SACK选项，另一个字节指明这个选
项要占用多少字节。如果要报告5个字节块的边界信息，那么至少需要42个字节。这就超
过了选项长度40字节的上限。互联网建议标准RFC2018还对报告这些边界信息的格式都做出了非常明确的规定，这里从略。
然而，SACK文档并没有指明发送方应当怎样响应SACK。因此大多数的实现还是重传所有未被确认的数据块。
•235•
### 分块 1
7.3鉴别7.3.1报文鉴别(authentication)
一一是网络安全中在网络的应用中，鉴别
不相同的概念。鉴别的内容有二。
是要鉴别发信者，即验证通信的对方的确是自己所要通
信的对象，而不是其他的冒充者。这就是实体鉴别。实体可以是发信的人，也可以是
个进
程（客户或服务器）。因此这也常称为端点鉴别。二是要鉴别报文的完整性，即对方所传送
的报文没有被他人篡改过。至于报文是否需要加密，则是与
性质不同的问题。有的
报文需要加密（这要另找措施），但许多报文并不需要加密。
个很重要的问题。鉴别和加密是(authorization)鉴别一““请注意，鉴别与授权也是不同的概念。授权涉及的问题是：所进行的过程是否被允许（如是否可以对某文件进行读或写）。
一不过有时常用报文鉴别词包含上述鉴别的两个内容，既鉴别报文的发送者，也鉴别报文的完整性。
下面分别讨论报文鉴别与实体鉴别的特点。
1.用数字签名进行鉴别（原理）我们知道，书信或文件可根据亲笔签名或印章来鉴别其真实性。但在计算机网络中传AXD7-4DA”“A进行为了进行数字签名，送的报文，则可使用数字签名进行鉴别。下面就介绍数字签名的原理。

### 分块 2
用其私钥SK
运算（如图对报文
运算本
7-4
来叫作解密运算。可是，还没有加密怎么就进行解密呢？其实D运算只是把报文变换为某
种不可读的密文（因此有时也说成
中
，就是为了避免产生这种误解。A把经过D运算得
我们使用
到的密文传送给B。B为了核实签名，用A的公钥进行E运算，还原出明文X。请注意，
任何人用A的公钥PK
哥
式并非为了保密，而是为了进行签名和核实签名，即确认此明文的确是A
进行E运算后都可以得出A发送的明文。可见图用其私钥对报文加密，但这样说不准确）。在图而不是
A所示的通信方解密运算发送的。
D运算所示）。
7-4““A的私钥SKl签名密文DSK\（X)、\密又DsK,,(X)图用数字签名进行鉴别7-4A
下为什么数字签名具有鉴别报文的功能。
AA一A
下面讨论B(X)DSKA因为除外没有别人持有的私钥SK,所以除外没有别人能产生密文。
这样，B确信报文X是A签名发送的。这就鉴别了报文的发送者。同理，其他人如果篡改
过报文，但由于无法得到A的私钥SK
对篡改后的报文进行D运算，那么B对收到的报文

### 分块 3
过报文，但由于无法得到A的私钥SK
对篡改后的报文进行D运算，那么B对收到的报文
进行核实签名的E运算后，将会得出不可读的明文，因而不会被欺骗。这样就保证了报文
的完整性。
一A数字签名还有另功能，就是发送者事后不能抵赖对报文的签名。这叫作不可否认。
•341•若A要抵赖曾发送报文给B,B可把X及DSKA(X)出示给进行公证的第三者。第三者很容易用PKA去证实A确实发送X给B。
以上这三项功能的关键都在千没有其他人能够持有A的私钥SKAo
但数字签名仅对报文进行了签名，对报文X本身却未保密。因为截获到密文DSKA(X)并知道发送者身份的任何人，若通过某种手段获得了发送者的公钥PKA,就能解出报文的
内容。如果用图7-5所示的方法，就可同时实现保密通信和数字签名。图中SKA和SKB分
别为A和B的私钥，而PKA和PKB分别为A和B的公钥。请注意，在许多情况下，我们
用A的私钥对明
往往强调的是使用何种密钥进行运算，这时的表达方式可简单些。例如，“文X进行签名可记为SKA(X)。若再用B的公钥对此签名进行加密，则可记为““＂PKs(SKA(X))，而不必深究使用的是D运算还是E运算。

### 分块 4
A
A的私钥SK8
］
B的私钥SKA
A的公钥PK
了B•加密与解密
签名与核实签名
图7-5可保证机密性的数字签名，如图7-5所示的可保证机密性的数字签名方法，虽然在理论上是正确的，但很难用于现
”“实生活中。因此这节的小标题后边有原理二字。这是因为要对报文（可能很长的报文）一先后要进行两次D运算和两次E运算，这种运算量太大，要花费非常多的计算机CPU时间，在很多情况下是无法令人接受的。因此目前对网络上传送的大量报文，普遍都使用开销小得多的对称密钥加密。要实现数字签名当然必须使用公钥密码，但一定要设法减小公钥密码算法的开销。这就要使用后面几个小节所讨论的密码散列函数和报文鉴别码。
2.密码散列函数散列函数（又称为杂凑函数，或哈希函数）在计算机领域中使用得很广泛。密码学对散列函数有非常高的要求，因此符合密码学要求的散列函数又常称为密码散列函数

### 分块 5
(cryptographichashfunction)。以后在不致产生错误概念时，我们也常把密码散列函数简称为散列函数。具体说来，密码散列函数H(X)应具有以下四个特点：(1)虽然散列函数的输入报文X的长度不受限制，但计算出的结果H(X)的长度则应是较短的和固定的。散列函数的输出H(X)又称为散列值，或散列。散列函数采用确定算法，因此相同的输入必定得出相同的输出。虽然密码散列函数相当复杂，但利用计算机，散列函数的运算还是相当快的。
(2)散列函数的输入和输出的关系是多对一的。若散列值H(X)的长度为128位，那么输出散列值只有281
2个有限多的可能值(2128与IPv6的地址数一样大，是个很大的数值）。
然而我们的输入报文X却有无限多的取值。可见必然会出现不同输入却产生相同输出的碰撞现象。精心挑选的密码散列函数应当非常不易发生碰撞，即应具有很好的抗碰撞性。
•342•(3)若给出散列值H(X),则无人能找出输入报文X。也就是说，散列函数是一种单向函数(one-wayfunction)，即逆向变换是不可能的（如图7-6所示）。
俨·｀任意长度的明文X这是要发达的个
I`·�`••

### 分块 6
俨·｀任意长度的明文X这是要发达的个
I`·�`••
心婓加光的明文
长度不限．
I一一····-·•Iv�i`、}/
/＇＿;,输出固定长度
的散列值H(X)
10010...
········-·············一
一1011
．气．一..----．霆上述特点的另一种表述方法是：图7-6密码散列函数是单向的若已知X和H(X),则没有人能够找到Y(Y-=f:.X)，使得H(Y)=H(X)。
但下面我们要讲到，关千这方面的研究，后来已有了
(4)好的密码散列函数还具有这样
一一些特性：散列函数输出的每一些新的进展。
一个比特，都与输入的个比特有关；哪怕仅改动输入的个比特，输出也会相差极大；散列函数的运算包括许一每
多非线性运算。
通过许多学者的不断努力，已经设计出些实用的密码散列函数（或称为散列算法），
其中最出名的就是MD5和SHA-1。MD就是MessageDigest的缩写，意思是报文摘要。
MD5是报文摘要的第5个版本。
一设计者Rivest曾提出
有相同报文摘要的另一报文摘要算法MD5公布于RFC1321

### 分块 7
一设计者Rivest曾提出
有相同报文摘要的另一报文摘要算法MD5公布于RFC1321
一个猜想，即根据给定的MD5报文摘要代码，要找出一个与原来报文C1991年），并获得了非常广泛的应用。MD5的报文，其难度在计算上几乎是不可能的。但在2004年，中国学者王小云CD发表了轰动世界的密码学论文，证明可以用系统的方法找出一对报文，这对报文具有相同的MD5报文摘要[W-WANG]，而这仅需15分钟，或不到1小时。千是，MD5的安全
一性就产生了动摇。随后，又有许多学者开发了对MD5实际的攻击。于是MD5最终被另种叫作安全散列算法SHA(SecureHashAlgorithm)的标准所取代。
下面仍以MD5为例来介绍报文摘要。这主要是考虑到目前新的散列函数（如SHA-2)是从MD5发展而来的。对于有兴趣研究散列函数的读者，MD5是个很好的出发点。
MD5算法的大致过程如下：
(1)先把任意长的报文按模264计算其余数(64位），追加在报文的后面。
(2)在报文和余数之间填充1~512位，使得填充后的总长度是512的整数倍。填充的首位是l，后面都是0。

### 分块 8
(3)把追加和填充后的报文分割为许多512位的数据块，每个512位的报文数据再分成4个128位的数据块依次送到不同的散列函数进行4轮计算。每
块进行复杂的运算。一直到最后计算出MD5报文摘要代码(128位）。
位都与原来报文中的每这样得出的MD5报文摘要代码中的每一一位有关。由此可见，一轮又都按32位的小数据像MD5这样的密码散列函数实际上已是个相当复杂的算法，而不是简单的函数了。
SHA-1是由美国标准与技术协会NIST提出的一个散列算法系列。SHA-1和MD5相似，O注：王小云，女，1966年出生，山东大学和清华大学教授，中国科学院院士，主要研究领域为密码学和信息安全学。
•343•但其散列值的长度为160位（比MD5的128位多了25%）。SHA-I也是先把输入报文划分
为许多512位长的数据块，然后经过复杂运算后得出散列值。SHA-I比MD5更安全，但计
算起来却比MD5要慢些。1995年发布的新版本SHA-I[RFC3174]在安全性方面有了很大的
改进。
但SHA-I后来也被证明其实际安全性并未达到设计要求，并且也曾被王小云教授的研

### 分块 9
改进。
但SHA-I后来也被证明其实际安全性并未达到设计要求，并且也曾被王小云教授的研
究团队攻破。谷歌也宣布了攻破SHA-I的消息。现在SHA-I已被另外的两个版本SHA-2
[RFC6234]和SHA-3[W-SHA3]所替代。SHA-2和SHA-3都各有好几种变型。前者有SHA-224,SHA-256,SHA-384和SHA-512,后者有SHA3-224,SHA3-256,SHA3-384和SHA3-512。
在上面名称最后的3位数字表示散列的位数。这里需要指出，SHA-3采用了与SHA-2完全不同的散列函数。现在许多组织都已纷纷宣布停用SHA-I。例如，微软千2017年1月1日
起停止支持SHA-I证书，而以前签发的SHA-1证书也必须更换为SHA-2证书。
＂
，是指有人能设法找出具有相同散列值的请注意，MD5或SHA-I对报文。
被攻破一”这样就动摇了MD5或SHA-I的安全性。但是，密码学家目前尚无法把X,篡改为具有同样MD5或SHA-I散列值的另一报文Y。
一个任意已知的报文3.用报文鉴别码实现报文鉴别一下面进步讨论怎样使用散列函数来实现报文鉴别。

### 分块 10
一个任意已知的报文3.用报文鉴别码实现报文鉴别一下面进步讨论怎样使用散列函数来实现报文鉴别。
下面给出的三个简单步骤，给出鉴别报文的初步概念。
(1)用户A首先根据自己的明文X计算出散列H(X)（例如，使用MD5)。为简单起见，我们把得出的散列H(X)记为H。
(2)用户A把散列H拼接在明文X的后面，生成了扩展的报文(X,H)，然后发送给B。
(3)用户B收到了这个扩展的报文(X,H)。因为散列的长度H是早已知道的固定值，因此很容易把收到的散列H和明文X分离开。B通过散列函数的运算，计算出所收到的明文X的散列H(X)。若H(X)=H,则B就认为所收到的明文是A发送过来的。
但上述做法实际上是不可行的。设想某个入侵者创建了个伪造的报文M,然后也用
同样的方法计算出其散列H(M)，并且冒充A把拼接有散列的扩展报文发送给B。B收到扩
展的报文(M,H(M)）后，按照上面步骤(3)的方法进行验证，发现切都是正常的，就会误认一一为所收到的伪造报文就是A发送的。

### 分块 11
因此，必须设法对上述的攻击进行防范。解决的办法可以是：A把双方共享的密钥K(K就是－串不太长的字符串）拼接到报文X后，进行散列运算（如图7-7所示）。散列运算得出的结果为固定长度的H(X+K),称为报文鉴别码MAC(MessageAuthenticationCode)。请注意：局域网中使用的媒体接入控制MAC正好也使用这三个字母，因此在看到缩写词MAC时应注意上下文。A把报文鉴别码MAC拼接在报文X后面，得到扩展的报文，发送给B。我们注意到，共享密钥K并没有出现在网上传送的扩展的报文中。
B收到扩展的报文后，把报文鉴别码MAC与报文X进行分离。B再用同样的密钥K与报文X拼接，进行散列运算，把得出的结果H(X+K)与分离出的报文鉴别码MAC进行比较。
如相等，就可确认收到的报文X的确是A发送的。只要入侵者不掌握密钥K,就无法伪造A的报文鉴别码MAC,因而无法伪造A发送的报文。像这样的报文鉴别码称为数字签名，或数字指纹。图7-7所示的过程就是A对报文进行了签名，而B对报文进行了鉴别。

### 分块 12
•344•二厂图7-7用报文鉴别码MAC鉴别报文；一图7-7所示的鉴别过程并没有执行加密算法，只是在计算散列值时在报文后面拼接了密钥，因此这种鉴别报文的方法消耗的计算资源很少，但却能有效地保护报文的完整性。
一在许多有关鉴别的文献中，常常看到在MAC前面加上个H的写法，即HMAC(Hashed
MAC)。MAC与HMAC的区别如图7-8所示[PETE12,第646页］。前面图7-7所示的MAC
实际上就是HMAC。计算HMAC是规定把密钥K拼接在明文后面，然后使用密码散列算法
对其进行运算，得出的散列值就是HMAC。但在计算MAC时则不
定这样做。首先，密
一
钥K不
定非要拼接在明文的后面，只要把密钥K作为
个计算MAC的参数即可。其次，
可以有多种计算MAC的算法，不
定非要使用严格的密码散列算法。在RFC2104中，对
各种不同情况下HMAC的计算方法都有着详细的规定。但在本书中，为了方便，对MAC
和HMAC可视为同义词。
一一图7-8MAC与HMAC的区别一一

### 分块 13
和HMAC可视为同义词。
一一图7-8MAC与HMAC的区别一一
上述这种鉴别报文的方法还有些问题有待解决。例如，采用怎样安全有效的方法来分发通信双方共享的密钥K?另种可行的方法是采用公钥系统。我们用图7-9来说明。
已签名的非固定长度
的报文鉴别码不安全的
互联网－-报文X
扩展的报文一1总立妳芯汹夕飞$
发送A的公长度的报文鉴别码图7-9使用已签名的报文鉴别码对报文鉴别用户A对报文X进行散列运算，得出固定长度的散列H(X)。用自己的私钥对H(X)进行D运算（也可以说成是用私钥进行加密），得出已签名的但非固定长度的报文鉴别码MAC。
•345•请注意，这里没有对报文X进行加密，而是对很短的散列H(X)进行D运算，因此这种运算
仍然是很快的。A把已签名的非固定长度的报文鉴别码MAC,拼接在报文X后面，构成扩
展的报文发送给B。
B收到扩展的报文后，先进行报文分离。虽然B不知道已签名的报文鉴别码的长度，但由千报文X是明文，其结束处可以设有标记，因此分离出MAC不困难。分离后，B对报
文X进行散列函数运算，同时用A的公钥对分离出的已签名的报文鉴别码MAC进行E运

### 分块 14
文X进行散列函数运算，同时用A的公钥对分离出的已签名的报文鉴别码MAC进行E运
算（也可以说成是用公钥进行解密）。最后对这两个运算结果H(X)进行比较。如相等，就说
切正确。由千入侵者没有A的私钥，因此不可能伪造出A发出的报文。这里我们假定一明
B事先知道A的公钥。
“”不难看出，采用这种方法得到的扩展的报文，不仅是不可伪造的，也是不可否认的。
图7-9所示的过程，可简称为：
7.3.2实体鉴别A用自己的私钥进行签名，B用A的公钥进行鉴别。
实体鉴别和报文鉴别不同。报文鉴别是对每个收到的报文都要鉴别报文的发送者，一而实体鉴别是在系统接入的全部持续时间内对和自已通信的对方实体只需验证次。
一最简单的实体鉴别过程如图7-10所示。A向远端的B发送带有自己身份A（例如，A
进行加密。B收到此报文的姓名）和口令的报文，并且使用双方约定好的共享对称密钥K
进行解密，从而鉴别了实体A的身份。

### 分块 15
进行解密，从而鉴别了实体A的身份。
后，用共享对称密钥KABAB图7-10仅使用对称密钥传送鉴别实体身份的报文然而这种简单的鉴别方法具有明显的漏洞。例如，入侵者C可以从网络上截获A发给B的报文，C并不需要破译这个报文（因为破译可能很费时间），而是直接把这个由A加密
的报文发送给B,使B误认为C就是A;然后B就向伪装成A的C发送许多本来应当发给
A的报文。这就叫作重放攻击(replayattack)。C甚至还可以截获A的IP地址，然后把A的
IP地址冒充为自己的IP地址（这叫作IP欺骗），使B更加容易受骗。
为了对付重放攻击，可以使用不重数(nonce)。不重数就是个不重复使用的大随机数，“一一一”次即
开。图7-11给出了这个过程。

### 分块 16
开。图7-11给出了这个过程。
数A。在鉴别过程中不重数可以使B能够把重复的鉴别请求和新的鉴别请求区分B时间图7-ll使用不重数进行鉴别•346•在图7-11中，A首先用明文发送其身份A和一个不重数RA给B。接着，B响应A的查问，用共享的密钥KAB对队加密后发回给A,同时也给出了自己的不重数RB。最后，A再响应B的查问，用共享的密钥KAB对岛加密后发回给B。这里很重要的一点是A和B对不同的会话必须使用不同的不重数集。由千不重数不能重复使用，所以C在进行重放攻击时无法重复使用所截获的不重数。
在使用公钥密码体制时，可以对不重数进行签名鉴别。例如在图7-11中，B用其私钥对不重数凡进行签名后发回给A。A用B的公钥核实签名，如能得出自己原来发送的不重
数RA，就核实了和自已通信的对方的确是B。同样，A也用自己的私钥对不重数岛进行签
名后发送给B。B用A的公钥核实签名，鉴别了A的身份。
公钥密码体制虽然不必在互相通信的用户之间秘密地分配共享密钥，但仍有受到攻击的可能。让我们看下面的例子。
C冒充是A,发送报文给B,说：“我是A”
。
一B选择个不重数RB，发送给A,但被C截获了。

### 分块 17
C冒充是A,发送报文给B,说：“我是A”
。
一B选择个不重数RB，发送给A,但被C截获了。
C用自己的私钥S尺冒充是A的私钥，对彻加密，并发送给B。
B向A发送报文，要求对方把解密用的公钥发送过来，但这报文也被C截获了。
C把自己的公钥PKc冒充是A的公钥发送给B。
B用收到的公钥P长对收到的加密的岛进行解密，其结果当然正确。于是B相信通信的对方是A,接着就向A发送许多敏感数据，但都被C截获了。
然而上述这种欺骗手段不够高明，因为B只要打电话询问A根本没有和B进行通信。但下面的中间人攻击欺骗性。图7-12是中间人攻击“＂“一“下A就能戳穿骗局，因为
(man-in-the-middleattack)就更加具有的示意图。
B时间图7-12中间人攻击从图7-12可看出，A想和B通信，向B发送我是A"的报文，并给出了自己的身份。
““
C截获，C把这个报文原封不动地转发给B。B选择一个不重数RB这个报文被
发送给A,但同样被C截获后也照样转发给A。
中间人“中间人C用自己的私钥SKc对彻加密后发回给B,使B误以为是A发来的。A收到

### 分块 18
中间人“中间人C用自己的私钥SKc对彻加密后发回给B,使B误以为是A发来的。A收到
岛后也用自己的私钥SKA对岛加密后发回给B,但中途被C截获并丢弃。B向A索取其
公钥，这个报文被C截获后转发给A。
C把自己的公钥PKc冒充是A的公钥发送给B，而C也截获到A发送给B的公钥PK氏
B用收到的公钥PKc（以为是A的）对数据DATA加密，并发送给A。C截获后用自
份留下，然后再用A的公钥PKA对数据DATA加密后发送给A。
•347•己的私钥S应解密，复制一A收到数据后，用自己的私钥SK
加密数据已被中间人C截获并解密了份，但A和B却都不知道。
一解密，以为和B进行了保密通信。其实，B发送给A的A一由此可见，公钥的分配以及认证公钥的真实性也是个非常重要的问题。关于这点我们在后面(7.4.2节）还要讨论。
7.4密钥分配一由于密码算法是公开的，网络的安全性就完全基于密钥的安全保护上。因此在密码学
密钥管理。密钥管理包括：密钥的产生、分配、注入、验证和中出现了
使用。本节只讨论密钥的分配。
个重要的分支密钥分配（或密钥分发）是密钥管理中最大的问题。密钥必须通过最安全的通路进行

### 分块 19
个重要的分支密钥分配（或密钥分发）是密钥管理中最大的问题。密钥必须通过最安全的通路进行
分配。例如，可以派非常可靠的信使携带密钥分配给互相通信的各用户。这种方法称为网外
分配方式。但随着用户的增多和网络流侬的增大，密钥更换频繁（密钥必须定期更换才能做
到可靠），派信使的办法已不再适用，而应采用网内分配方式，即对密钥自动分配。
7.4.1对称密钥的分配一一对称密钥分配存在以下两个问题。
一
，如果n个人中的每第两人共享个需要和其他n-l个人通信，就需要n(n-l)个密钥。但每
个密钥，因此密钥数是n(n-1)/2。这常称为矿问题。如果n是个很大的数，所需要的密钥数量就非常大。
第二，通信的双方怎样才能安全地得到共享的密钥呢？正是因为网络不安全，所以才需要使用加密技术。但密钥又需要怎样传送呢？
一
大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配目前常用的密钥分配方式是设立密钥分配中心KDC(KeyDistributionCenter)oKDC是
个会话密钥（仅使用
次）。在图7-13中假定用户A和B都是KDC的登记用户。A和B在KDC登记时就已经
＂
和KB。为简单起

### 分块 20
＂
和KB。为简单起
。密钥分配分为三个步骤（如图7-13中带箭在KDC的服务器上安装了各自和KDC进行通信的主密钥(masterkey)K
见，下面在叙述时把
简称为
头直线上的O,＠和＠所示）。
主密钥密钥A““＂一A密钥分配中心
KDCB＠时间图7-13KDC对会话密钥的分配0用户A向密钥分配中心KDC发送时用明文，说明想和用户B通信。在明文中给出•348•


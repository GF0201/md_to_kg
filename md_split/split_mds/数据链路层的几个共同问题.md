### 分块 1
H2都有完整的
压发送数据时，从协议的层次上看，数据的流动如图
五层协议栈，但路由器在转发分组时使用的协议栈只有下面的三层G)。数据进入路由器后要
先从物理层上到网络层，在转发表中找到下一跳的地址后，再下到物理层转发出去。因此，
数据从主机凡传送到主机H2需要在路径中的各节点的协议栈向上和向下流动多次，如图中
的浅灰色箭头所示。
所示。主机H几3-l(b)D然而当我们专门研究数据链路层的问题时，在许多情况下我们可以只关心在协议栈中
水平方向的各数据链路层。千是，当主机H1向主机H2发送数据时，我们可以想象数据就是
在数据链路层从左向右沿水平方向传送，如图3-2中从左到右的粗箭头所示，即通过以下这
样的链路：凡的链路层一民的链路层一民的链路层一民的链路层一止的链路层HIH2图3-2只考虑数据在数据链路层的流动图3-2指出，从数据链路层来看，凡到H2的通信可以看成由四段不同的链路层通信组
成，即：H1-R1,R1-R2,R尸民和R3-H2。这四段不同的链路层可能采用不同的数据链
路层协议。

### 分块 2
路层协议。
3.1数据链路层的几个共同问题本节重点讨论使用点对点信道的数据链路层的一些基本问题。其中的某些概念对广播信道也是适用的。
．扫一扫回“．．。
回事3．ll据数链路禾晴贞-““"，，我门
1在、这里要明确，下所1
胃路
链、mk
l
（）
就是从一个链节口
各
占�和数据链廿
P令B点的／一护
 各
段是
并
不
乡物
戈
理路（有线或无线）而中—
司没有／任何其1
也的交奂
1节间的通信路径主
往
1妇又
工过许多艾
f这样甘
勺护令
连在进
io了
1数据通信时，两台计算机之可见链路只是－条－路径的组成部分至相
lj
占�。
频畔融视。
数据链一路必须有条物Cd
理atahnk）
则是另入1概。
念这是因为当需要在条线路上传送数据，时除了配，卜还必夕／
员有一些必要的通信协议来控线些数据的传输将在后面几节讨论。
）若把实现这些协议的硬件和欠
车件加到链路上＇成了数据链路0在最常用这告
l}
就
构这
(
现句注：当路由器之间在交换路由信息时，根据所使用的路由选择协议的不同，也有可能需要使用运输层协议。见下一章的4.5节。

### 分块 3
•72•的方法是使用网络适配器（既有硬件，也包括软件）来实现这些协议。一般的适配器都包括
了数据链路层和物理层这两层的功能。
也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。物理链路就是上面所说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。
早期的数据通信协议曾叫作通信规程(procedure)。因此在数据链路层，规程和协议是同义语。
下面再介绍点对点信道的数据链路层的协议数据单元一一－帧。
数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据
取出并上交给网络层。在互联网中，网络层协议数据单元就是IP数据报（或简称为数据报、
分组或包）。
为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图3-3(a)所示的三层
模型。在这种三层模型中，不管在哪一段链路上的通信（主机和路由器之间或两个路由器之
间），我们都看成是节点和节点的通信（如图中的节点A和节点B)，而每个节点只有下三
层网络层、数据链路层和物理层。

### 分块 4
层网络层、数据链路层和物理层。
节点A节点B网络层物理层“雪，，＿链路上传送的是电信号或光信号，，m、节点A数据链路层链路(a)三层的简化模型链路上传送的是帧链路(b)只考虑数据链路层节点B图3-3使用点对点信道的数据链路层点对点信道的数据链路层在进行通信时的主要步骤如下：
(1)节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。
(2)节点A把封装好的帧发送给节点B的数据链路层。
(3)若节点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层；否则丢弃这个帧。
数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如图3-3(b)所示。
扫3.1.2三个基本问题扫一数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：封装成帧、透明传输和差错检测。下面分别讨论这三个基本问题。
酱视频讲解•73•1.封装成帧封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。

### 分块 5
接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别
帧的开始和结束。图3-4表示用帧首部和帧尾部封装成帧的一般概念。我们知道，分组交换
的一个重要概念就是：所有在互联网上传送的数据都以分组（即IP数据报）为传送单位。
网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面
分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。
一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作
用就是进行帧定界（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在
发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确
的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大千首部和尾部
的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限
最大传送
单元MTU(MaximumTransferUnit)。图3-4给出了帧的首部和尾部的位置，以及帧的数据部
分与MTU的关系。
帧开始
l
发送
一门仇首部1

### 分块 6
分与MTU的关系。
帧开始
l
发送
一门仇首部1
臼『I从这里升始发送IP数据报帧结束l帧的数可部分1帧尾部<MTU|数据链路层的帧长图3-4用帧首部和帧尾部封装成帧当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。
我们知道，ASCII码是7位编码，一共可组合成128个不同的ASCII码，其中可打印的有
95个气而不可打印的控制字符有33个。图3-5的例子可说明帧定界的概念。控制字符SOH
(StartOfHeader)放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT(EndOf
Transmission)表示帧的结束。请注意，SOH和EOT都是控制字符的名称。它们的十六进制
编码分别是01（二进制是00000001)和04（二进制是00000100)。SOH（或EOT)并不是
S,0,H（或E,0,T)三个字符。此外，为了强调帧定界符的作用，与帧定界符无关的控制
信息在图3-5中都省略了。

### 分块 7
信息在图3-5中都省略了。
压帧符三发送在前装在帧中的数据部分帧图3-5用控制字符进行帧定界的方法举例帧结束符“注：可打印的字符”“就是可以从键盘卜输入的字符＂（因而也是可打印出的）。我们使用的标准键盘有47个键可输入94个字符（包括使用Shift键），加上空格键，一共可输入95个可打印字符。
O•74•当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一
个帧时突然出故障，中断了发送。但随后很快又恢复正常，千是重新从头开始发送刚才未发
送完的帧。由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部
开始符SOH而没有传输结束符EOT)，必须丢弃。而后面收到的数据有明确的帧定界符
(SOH和EOT)，因此这是一个完整的帧，应当收下。
2.透明传输由千帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。
当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数

### 分块 8
当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数
据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字
符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。
但当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序或图像等），情
况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样
（如图3-6所示），数据链路层就会错误地”找到帧的边界“，把部分帧收下（误认为是个完
整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH)。
“出现了EOT"完整的帧数据部分SOH发送在前误认为是个帧一被接收端当作无效帧而丢弃图3-6数据部分恰好出现与EOT一样的代码“EOT”时就传不过去了。数据中的“EOT”将被接收端错误地解释为像图3-6所示的帧的传输显然就不是“透明传输＂，因为当遇到数据中碰巧出现字符
“传输结束＂的控制
字符，而在其后面的数据因找不到“SOH"被接收端当作无效帧而丢弃。但实际上在数据中
出现的字符“EOT"并非控制字符而仅仅是二进制数据00000100。

### 分块 9
出现的字符“EOT"并非控制字符而仅仅是二进制数据00000100。
前面提到的＂透明”是一个很重要的术语。它表示：某一个实际存在的事物看起来却
好像不存在一样（例如，你看不见在你前面有块100％透明的玻璃的存在）。”在数据链路层
透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数
据链路层。因此，对所传送的数据来说，这些数据就“看不见“数据链路层有什么妨碍数据
传输的东西。或者说，数据链路层对这些数据来说是透明的。
为了解决透明传输问题，就必须设法使数据中可能出现的控制字符“SOH"和“EOT"
在接收端不被解释为控制字符。具体的方法是：发送端的数据链路层在数据中出现控制字符
“SOH”或“EOT"的前面插入一个转义字符“ESC"（其十六进制编码是lB,二进制是
00011011)。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这
种方法称为字节填充(bytestuffing)或字符填充(character
stuffing)。如果转义字符也出现在数据

### 分块 10
stuffing)。如果转义字符也出现在数据
当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续
的两个转义字符时，就删除其中前面的一个。图3-7表示用字节填充法解决透明传输的问题。
•75•符』巾』
三,＇字节填充，＇，'，
，，三，发送
在前3.差错检测原始数据三I-ESC|字节填充｝字节填充＼帧结束符
｝|SOHIIEOT|、
字节填允．．勹二厂曰经过字节填充后发送的数据图3-7用字节填充法解决透明传输的问题现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：
l可
能会变成O,而O也可能变成1。这就叫作比特差错。比特差错是传输差错中的一种。本小节
所说的＂差错＂，如无特殊说明，就是指“比特差错＂。在一段时间内，传输错误的比特占所
传输比特总数的比率称为误码率BER(BitErrorRate)。例如，误码率为10-10时，表示平均每
传送1010个比特就会出现一个比特的差错。误码率与信噪比有很大的关系。如果设法提高信
噪比，就可以使误码率减小。实际的通信链路并非是理想的，它不可能使误码率下降到零。

### 分块 11
噪比，就可以使误码率减小。实际的通信链路并非是理想的，它不可能使误码率下降到零。
因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。
目前在数据链路层广泛使用了循环冗余检验CRC(CyclicRedundancyCheck)的检错技术。
下面我们通过一个简单的例子来说明循环冗余检验的原理。
在发送端，先把数据划分为组，假定每组k个比特。现假定待传送的数据M=101001
(k=6)。CRC运算就是在数据M的后面添加供差错检测用的n位冗余码，然后构成一个
帧发送出去，一共发送(k+n)位。在所要发送的数据后面增加n位的冗余码，虽然增大了数
据传输的开销，但却可以进行差错检测。当传输可能出现差错时，付出这种代价往往是很值
得的。
这n位冗余码可用以下方法得出。用二进制的模2运算＠进行2n乘M的运算，这相当
千在M后面添加n个0。得到的(k+n)位的数除以收发双方事先商定的长度为(n+1)位的除
数P,得出商是Q而余数是R(n位，比P少一位）。关千除数P下面还要介绍。在图3-8
所示的例子中，M=101001

### 分块 12
所示的例子中，M=101001
（即k=6)。假定除数P=1101（即n=3)。经模2除法运算后
的结果是：商Q=110101（这个商并没有什么用处），而余数R=001。这个余数R就作为
冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码常称为帧检验序
（即2nM+FCS),
列FCS(FrameCheckSequence)。因此加上FCS后发送的帧是101001001
共有(k+n)位。
顺便说一下，循环冗余检验CRC和帧检验序列FCS并不是同一个概念。CRC是一种
检错方法，而FCS是添加在数据后面的冗余码，在检错方法上可以选用CRC,但也可不选
用CRC。
心注：用模2运算进行加法时不进位，例如，1111+1010=0101。减法和加法一样，按加法规则计算。
•76•110101--Q（商）P（除数）一11Ol|101001000-2“M（被除数）1101:::''
1110::
1101:0111:垒．1110
11010110
00001100

### 分块 13
1110::
1101:0111:垒．1110
11010110
00001100
1101001--R（余数），作为FCS图3-8说明循环冗余检验原理的例子一在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每个帧都除以同样的除数P（模2运算），然后检查得到的余数R。
一如果在传输过程中无差错，那么经过CRC检验后得出的余数R肯定是0（读者可以自已验算下。被除数现在是101001001,而除数是P=llOl,看余数R是否为0)。
但如果出现误码，那么余数R仍等千零的概率是非常非常小的（这可以通过不太复杂的概率计算得出，例如，可参考[TANEll]）。
一总之，在接收端对收到的每帧经过CRC检验后，有以下两种情况：一
(1)若得出的余数R=O,则判定这个帧没有差错，就接受(accept)。
(2)若余数RO,则判定这个帧有差错（但无法确定究竟是哪-=1=位或哪几位出现了差错），就丢弃。

### 分块 14
(2)若余数RO,则判定这个帧有差错（但无法确定究竟是哪-=1=位或哪几位出现了差错），就丢弃。
3+x2+一种较方便的方法是用多项式来表示循环冗余检验过程。在上面的例子中，用多项式3P(X)=X1表示上面的除数P=1101（最高位对应千X,最低位对应于炉）。多项式P(X)称为生成多项式。现在广泛使用的生成多项式P(X)有以下几种：=X2xX
X
X
勹
气
32+x
6+x2
勹2CRC-16
CRC-CCITT=x+1
3+x
气X5+
22+
lCRC-32=x1勹X气炉＋x1x8°++x7++x2+x+5+
x4X1帧接
“在数据链路层，发送端帧检验序列FCS的生成和接收端的CRC检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。
从以上的讨论不难看出，如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验。因此，如果要在数据链路层进行差错检验，就必须把数据划分为一一一帧，每一
帧都加上冗余码，帧地传送，然后在接收方逐帧进行差错检验。
最后再强调下，在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能

### 分块 15
最后再强调下，在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能
凡是接收端数据链路层接受的帧，我们都能以非常接近千1
。接收端丢弃的帧虽然曾收到了，但最终还＂的概率认为这些帧在传输过程中没有产生差错做到对帧的无差错接受，即：”
是因为有差错被丢弃，即没有被接受。以上所述的可以近似地表述为（通常都是这样认为）：“凡是接收端数据链路层接受的帧均无差错。
“＂请注意，我们现在并没有要求数据链路层向网络层提供”可靠传输的服务。所谓“可靠传输就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为•77•一一两大类：类就是前面所说的最基本的比特差错，而另类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。例如，发送方连续传送一三个帧：［＃1]-[#2]-[#3]。假定接收端收到的每个帧都没有比特差错，但却出现下面的几种情况：帧丢失：收到[#l]-[#3]（丢失[#2]）。
帧重复：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2])。

### 分块 16
帧重复：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2])。
一帧失序：收到[#1]-[#3]-[#2]（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不样）。
”＂“＂以上三种情况都属千出现传输差错，但都不是这些帧里有比特差错。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。在学完第5章的5.4节后，我们就会知道在什么情况下接收端可能会出现帧重复或帧失序。
“”“”总之，我们应当明确，无比特差错与无传输差错并不是同样的概念。在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。
我们知道，过去OSI的观点是：必须让数据链路层向上提供可靠传输。因此在CRC检

### 分块 17
我们知道，过去OSI的观点是：必须让数据链路层向上提供可靠传输。因此在CRC检
错的基础上，增加了帧编号、确认和重传机制。收到正确的帧就要向发送端发送确认。发送一端在定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法：对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的TCP协议）来完成。
对千通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务（见第9章）。
实践证明，这样做可以提高通信效率。
可靠传输协议将在第5章中讨论。本章介绍的数据链路层协议都不是可靠传输的协议。
3.2点对点协议PPP在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是种好办法。因

### 分块 18
3.2点对点协议PPP在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是种好办法。因
此，能实现可靠传输的高级数据链路控制HDLC(High-levelDataLinkControl)就成为当时比较流行的数据链路层协议。但现在HDLC已很少使用了。对千点对点的链路，简单得多的点对点协议PPP(Point-to-PointProtocol)则是目前使用得最广泛的数据链路层协议。
3.2.1PPP协议的特点一我们知道，互联网用户通常都要连接到某个ISP才能接入到互联网。PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议（如图3-9所示）。
•78•

